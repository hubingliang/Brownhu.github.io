<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://brownhu.site</id>
    <title>Brown Hu</title>
    <updated>2019-10-18T12:04:05.616Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://brownhu.site"/>
    <link rel="self" href="https://brownhu.site/atom.xml"/>
    <subtitle>Better late then never</subtitle>
    <logo>https://brownhu.site/images/avatar.png</logo>
    <icon>https://brownhu.site/favicon.ico</icon>
    <rights>All rights reserved 2019, Brown Hu</rights>
    <entry>
        <title type="html"><![CDATA[缓存淘汰策略的三个代表]]></title>
        <id>https://brownhu.site/post/cache-strategy</id>
        <link href="https://brownhu.site/post/cache-strategy">
        </link>
        <updated>2019-09-23T16:16:29.000Z</updated>
        <content type="html"><![CDATA[<p>缓存是有空间的限制的，不同的情况下会采取不同的<strong>缓存淘汰策略</strong>应对缓存满载。常见的<strong>缓存淘汰策略</strong>有三种：</p>
<ul>
<li>先进先出策略 FIFO（First In，First Out）</li>
<li>最少使用策略 LFU（Least Frequently Used）</li>
<li>最近最少使用策略 LRU（Least Recently Used）</li>
</ul>
<h1 id="fifo">FIFO</h1>
<blockquote>
<p>先进先出，如果缓存容量满，则优先移出最早加入缓存的数据；其内部可以使用队列实现。</p>
</blockquote>
<p>简单理解其实就是：如果一个数据最先进入缓存中，则应该最早淘汰掉。</p>
<h1 id="lfu">LFU</h1>
<blockquote>
<p>根据数据的历史访问频率来淘汰数据，其核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。</p>
</blockquote>
<p>所以 LFU 的淘汰策略其实就是：如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小，所以优先淘汰。</p>
<h1 id="lru">LRU</h1>
<blockquote>
<p>least recently used，是目前最常用的缓存算法和设计方案之一，其移除策略为“当缓存（页）满时，优先移除最近最久未使用的数据”，优点是易于设计和使用，适用场景广泛。</p>
</blockquote>
<p>乍一看好像和 LFU 的区别不是很大，其实 LFU 和 LRU 的区别主要是判断的依据不一样，LFU 依据的是访问次数、LRU 依据的是多少时间没被访问。</p>
<p>举个例子：</p>
<ol>
<li>
<p>比如有数据：1，2，3，4</p>
</li>
<li>
<p>缓存大小为2：[]</p>
</li>
<li>
<p>我依次访问了1，2，1</p>
</li>
<li>
<p>缓存现在应该是 [1(2), 2(1)] (括号里面是访问的次数)</p>
</li>
<li>
<p>我现在又要访问3，这个时候就需要缓存淘汰策略了</p>
</li>
<li>
<p>对于 FIFO 应该很好理解，先进先出，我先访问的1，后访问的2，所以缓存变为[3(1).2(1)]</p>
</li>
<li>
<p>对于 LFU 淘汰访问次数最少的就可以了，缓存变成[3(1),1(2)]</p>
</li>
<li>
<p>LRU 我们要看哪个数据没被访问的时间最长，因为我最新一次访问的是1，所以淘汰2，缓存变成[3(1),1(2)]</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何打造一款自己的 VSCode 主题？]]></title>
        <id>https://brownhu.site/post/vscode-theme</id>
        <link href="https://brownhu.site/post/vscode-theme">
        </link>
        <updated>2019-04-18T09:21:54.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文首发于个人博客</p>
</blockquote>
<p>我之前一直用 <strong>One Dark Pro</strong> 后来又转到 <strong>Material Theme Palenight</strong> 再到后来的 <strong>Dracula</strong> 。总觉得有些配色很奇怪（工作太闲），于是写了一个 VSCode 深色主题：<a href="https://github.com/hubingliang/Duang">Duang</a>，之所以叫Duang是因为它很黑，很亮，很柔....</p>
<figure data-type="image" tabindex="1"><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a30374038ac5db?w=446&amp;h=315&amp;f=jpeg&amp;s=36465" alt=""></figure>
<p><a href="https://marketplace.visualstudio.com/items?itemName=Brownhu.duang">大家可以在这下载体验</a></p>
<p><a href="https://github.com/hubingliang/Duang">github 在这里</a></p>
<figure data-type="image" tabindex="2"><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a303c83daf3bb6?w=1514&amp;h=450&amp;f=png&amp;s=107690" alt=""></figure>
<figure data-type="image" tabindex="3"><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a3062d5015d575?w=1920&amp;h=1057&amp;f=png&amp;s=327708" alt=""></figure>
<p>如果你也对编辑器有自己独特风格的偏好，但是在成千上万款主题中又没有一款主题完全符合你的口味，那么跟着下面的流程我们自己动手做一个完全符合自己风格的主题吧。</p>
<hr>
<h2 id="注册你的开发者帐号和配置-token">注册你的开发者帐号和配置 token</h2>
<p>如果你安装过其他的 VSCode 主题的话应该知道，所有主题都属于 VSCode插件。那么要开发插件，必不可少的工具就是 <a href="https://github.com/Microsoft/vscode-vsce">vsce</a>，这个是官方管理插件的工具，所有插件都通过这个工具来发布。</p>
<p>如果你英文够好，建议看 VSCode 官网的这篇<a href="https://code.visualstudio.com/api/working-with-extensions/publishing-extension">文章</a>来学习从申请账号到发布插件的整个流程，非常详细。当然也可以跟着我后面的流程一起。</p>
<p>首先全局安装 <strong>vsce</strong> :</p>
<pre><code>npm install -g vsce
</code></pre>
<p>之后你需要去注册一个账号，网址在这：<a href="https://azure.microsoft.com/zh-cn/services/devops/">Azure DevOps Services | Microsoft Azure</a></p>
<p>登陆之后，首先新建一个 <strong>public</strong> 项目:</p>
<figure data-type="image" tabindex="4"><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fc45a7e1f7c1?w=627&amp;h=550&amp;f=png&amp;s=40656" alt=""></figure>
<figure data-type="image" tabindex="5"><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fbc998050c96?w=1492&amp;h=925&amp;f=png&amp;s=207120" alt=""></figure>
<p>然后获取你的 <strong>Personal access tokens</strong> ，点击右上角的头像，点击 <strong>Security</strong>。</p>
<figure data-type="image" tabindex="6"><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fc9eafaf6678?w=233&amp;h=279&amp;f=png&amp;s=13476" alt=""></figure>
<p>为你的 <strong>token</strong> 指定一个名称，时间的话最长到期可以设置为一年。</p>
<figure data-type="image" tabindex="7"><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fcf53e722c4a?w=1509&amp;h=1004&amp;f=png&amp;s=192787" alt=""></figure>
<p>点击查看所有的配置项，找到 <strong>Marketplace</strong> 并选择 <strong>Acquire</strong> and <strong>Manage</strong>：</p>
<figure data-type="image" tabindex="8"><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fd0406d2c348?w=1510&amp;h=1005&amp;f=png&amp;s=192921" alt=""></figure>
<p>点击 <strong>Create</strong> ，复制生成的 <strong>token</strong>，之后就要用到我们刚才安装的 <strong>vsce</strong> 来创建新的发布者（publisher）</p>
<pre><code>vsce create-publisher (发布者的名字)
</code></pre>
<p>回车之后会依次提示输入<strong>name</strong>、<strong>email</strong>，和你刚刚复制的 <strong>token</strong>。</p>
<p>现在你可以通过下面这个命令来登陆:</p>
<pre><code>vsce login (发布者的名字)
</code></pre>
<p>到此为止我们第一步就完成了，不要觉得繁琐，因为这些我们只需要配置一次就好了，每次开发插件的时候都不用重复这些操作。</p>
<p>如果你遇到文中没有提到的问题，我继续建议你看官方这两篇文章</p>
<ul>
<li><a href="https://docs.microsoft.com/zh-cn/azure/devops/organizations/accounts/create-organization?view=azure-devops">创建账号</a></li>
<li><a href="https://code.visualstudio.com/api/working-with-extensions/publishing-extension">发布扩展</a></li>
</ul>
<hr>
<h2 id="用脚手架生成基本的插件代码">用脚手架生成基本的插件代码</h2>
<p>之后我们需要安装一个脚手架工具：</p>
<pre><code>npm install -g yo generator-code
</code></pre>
<p>然后运行下面的命令👇，它可以在任何目录中生成一套基本的插件代码：</p>
<pre><code>yo code
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fe0fab9fb691?w=1060&amp;h=916&amp;f=png&amp;s=258431" alt=""></figure>
<p>我们要开发一个主题，所以选中 <strong>New Color Theme</strong>，之后会继续询问你是否新建主题还是从现有主题导入，我们这里选创建一个全新的。</p>
<figure data-type="image" tabindex="10"><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fe3e4302080e?w=2022&amp;h=184&amp;f=png&amp;s=116013" alt=""></figure>
<p>之后还会问你一些问题：</p>
<ul>
<li>插件名字</li>
<li>标识符</li>
<li>描述 （这个后面可以在<strong>package.json</strong>里面改）</li>
<li>发布者的名字 (见前文)</li>
<li>对于用户这个插件的名字</li>
<li>这个主题是dark还是light还是高对比度</li>
</ul>
<p>之后就会为我们生成一套主题插件的基本代码，到此为止我们已经完成了80%了，剩下的就只需要更改生成目录 <strong>themes</strong> 下的 <strong>json</strong> 文件就可以了，但是....</p>
<hr>
<h2 id="修改themes下的json文件">修改themes下的json文件</h2>
<p>看似很简单的事情，其实是我认为最难的，因为要设计一款，好看的主题，配色真的太难了！！！</p>
<p>很多我以为会很好看的颜色，改进去却like a shit....</p>
<p>em.....扯远了</p>
<p>首先用 VSCode 打开生成的目录，我们看到结构如下：</p>
<figure data-type="image" tabindex="11"><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a3009f1663e799?w=4096&amp;h=3072&amp;f=jpeg&amp;s=654365" alt="221555584047_.pic_hd.jpg"></figure>
<p>之后我们的工作都会在 <strong>themes</strong> 下的 <strong>json</strong> 文件展开，不要害怕，我们其实不需要看完这几百上千行 json 文件的意思。</p>
<p>首先我们先进去调试模式，看看脚本自动生成的主题是什么样子的：</p>
<figure data-type="image" tabindex="12"><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a300dbfbd72558?w=2048&amp;h=1536&amp;f=png&amp;s=366435" alt=""></figure>
<p>点击调试，会自动打开一个新的 VSCode 窗口展示预设的主题。</p>
<figure data-type="image" tabindex="13"><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a301018c9aec7d?w=2772&amp;h=1754&amp;f=png&amp;s=633003" alt=""></figure>
<p>接下来 <strong>Command + Shift + P</strong> 输入 <strong>Developer: Inspect TM Scopes</strong></p>
<figure data-type="image" tabindex="14"><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a30132c4f482c7?w=1190&amp;h=1094&amp;f=png&amp;s=165318" alt=""></figure>
<p>现在你可以看文件中每一个字符的颜色配置在哪了，只需要在 json 文件里搜对应的配置就好了。</p>
<p>如果你觉得不习惯，你甚至可以打开和 <strong>Chrome</strong> 一样的开发者工具，快捷键是 <strong>option + command + i</strong></p>
<figure data-type="image" tabindex="15"><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a3015c6f12955f?w=3840&amp;h=2114&amp;f=png&amp;s=2290633" alt=""></figure>
<p>不过我还是建议你用第一种方法，因为开发者工具有时候搜到颜色，但是你找不到配置项。</p>
<hr>
<h2 id="配色方案">配色方案</h2>
<p>如果你现在一无所措，改了一些颜色也不尽如人意，那就看下我的配色建议：</p>
<p>首先我的建议是，直接抄你喜欢或者成熟主题对应的 <strong>json</strong>文件，比如 <strong>One Dark Pro</strong> 、<strong>Material Theme Palenight</strong>、<strong>Dracula</strong></p>
<p>之所以这样是因为出于几个考虑：</p>
<ol>
<li>脚手架的配置项并不齐全，比如底部状态栏和侧边栏甚至光标的颜色都没有，而比较成熟下载量多的主题边边角角都配置到了，我们拿过来把对应的颜色全局替换就好了，不用再去官网上找对应的配置项。</li>
<li>并不是每种类型的字符配一种颜色，很多类型是复用同一种颜色的，但是对应关系并不好找，所以如果我们看到一个改一个很容易改的乱七八糟，所以拷贝过来之后每次改颜色，<strong>一定要全局替换，不要只改一个</strong>！！！</li>
<li>因为之前可能有了喜欢的主题，只不过主题之中有一些元素不喜欢而已，这样也会省下很多工作量。</li>
<li>你可以借鉴一些主题的颜色，或者整体风格，由于都在json文件里面，你可以很方便的找到它。</li>
</ol>
<p>那么问题来了，那些主题的 <strong>json</strong> 文件我去哪里找呢？</p>
<p><a href="https://vscodethemes.com/">这里</a>有几乎所有有名的 VSCode 主题，你可以点开看它的 <strong>github</strong> 那里就有它们的 <strong>json</strong> 文件，你可以clone整个项目，也可以单单只复制 <strong>json</strong> 。</p>
<p><strong>注意，不要全部复制过来，只复制 <strong>colors</strong> 和 <strong>tokenColors</strong> 就可以了。</strong></p>
<hr>
<p>至于颜色的选取这里推荐几个网站，供大家参考：</p>
<ol>
<li><a href="http://jxnblk.com/colorable/demos/text/">Colorable</a></li>
<li><a href="http://colorsafe.co/">colorsafe</a></li>
<li><a href="https://color.adobe.com/zh/create">Adobe Color CC</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[可能是最全的 Javascript 类型检查方案]]></title>
        <id>https://brownhu.site/post/type</id>
        <link href="https://brownhu.site/post/type">
        </link>
        <updated>2019-01-02T10:58:11.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文首发于我的个人博客 ：<a href="http://brownhu.site/">brownhu.site</a></p>
</blockquote>
<h2 id="前言">前言</h2>
<p>类型检查在各种强类型语言（Typescript、Flow.js）出现之前一直是我们手动检查的，检查的方式也是多种多样。本文尽量总结出所有类型最优的检查方式，和解释所有方式的原理，如果有错误请各位大佬指正，除此之外对于类型检查当然拥抱强类型我觉得才是未来。</p>
<p>es6 之后新加入了 Symbol 类型，目前为止 JavaScript 一共有 7 种类型，但其中还有分类（set WeakSet Map WeakMap），我们就基于这些类型来探索：</p>
<ul>
<li>null</li>
<li>undefined</li>
<li>boolean</li>
<li>number</li>
<li>string</li>
<li>object (set WeakSet Map WeakMap)</li>
<li>symbol(ES6 中新增)</li>
</ul>
<h2 id="typeof">Typeof</h2>
<p>首先是 Typeof，Typeof 可能是最多人所熟知的判断类型的方法，但是它并不完美，在有些情况下它的判断是有偏差的，我们来看看几个例子：</p>
<pre><code class="language-js">// 首先判断基本类型
typeof 1 // number
typeof 'Hellow world !' // string
typeof true // boolean
typeof null // object
typeof undefined // undefined

let s = Symbol()
typeof s // symbol
</code></pre>
<p>可以看到 null 的判断出了错误，这个大家看面试题也或多或少知道这个坑。<br>
然后我们再来看看引用类型：</p>
<pre><code class="language-js">const obj = Object.create(null) // 之所以这样创建是因为编程习惯...
function foo() {}
const arr = []
const s = new Set()
const ws = new WeakSet()
const m = new Map()
const wm = new WeakMap()

typeof obj // object
typeof foo // function
typeof arr // object
typeof s // object
typeof ws // object
typeof m // object
typeof wm // object
</code></pre>
<p>我们发现 typeof 在判断引用类型的时候并不能区分除了 function 以外其他类型的区别。至于为什么会出现这样的情况，就要看看 typeof 的原理。</p>
<h3 id="typeof-原理">typeof 原理</h3>
<p>在说原理之前需要先知道，js 是怎么储存数据类型的？</p>
<p>JavaScript 在底层储存变量时出于性能考虑会把数据的类型用前三位表示，typeof 就是通过前三位来判断类型：</p>
<ul>
<li>000: 对象</li>
<li>001: 整数</li>
<li>010: 浮点数</li>
<li>100: 字符串</li>
<li>110: 布尔</li>
</ul>
<p>两个特殊类型：</p>
<ul>
<li>undefined: -2^30</li>
<li>null: 全是 0</li>
</ul>
<p>因为 null 的机器码是全 0，它的类型标签自然就是 000，所以 typeof null 返回&quot;object&quot;。</p>
<h2 id="instanceof">instanceof</h2>
<p>instanceof 是有局限性的，它要求判断的目标必须是一个对象，与此同时 instanceof 的原理是判断只要右边的 prototype 出现在左边的原型链上就返回 true。所以说 instanceof 是判断一个实例是否是其父类型或者祖先类型的实例更为恰当。</p>
<p>代码的基本实现：</p>
<pre><code class="language-js">function instance_of(L, R) {    // L 表示左表达式，R 表示右表达式
 var O = R.prototype;           // 取 R 的显示原型
 L = L.__proto__;               // 取 L 的隐式原型
 while (true) { 
   if (L === null) 
     return false; 
   if (O === L)                 // 当 O 严格等于 L 时，返回 true 
     return true; 
   L = L.__proto__; 
 } 
}
</code></pre>
<p>还是看例子比较直接：</p>
<pre><code class="language-js">const obj1 = Object.create(null)
const obj2 = {}

obj1 instanceof Object // false
obj2 instanceof Object // true
</code></pre>
<p>通过这个例子你能很明确的想明白 instanceof 的原理，因为 obj1 是通过<code>Object.create(null)</code>来创建的，它原型链上什么都没有：</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2019/01/02/5c2c8b9a13878.png" alt=""></figure>
<p>而直接通过<code>{}</code>赋值生成的对象它的<code>_proto_</code>是指向 Object 的：</p>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2019/01/02/5c2c8bc36b1f2.png" alt=""></figure>
<p>所以判断结果就会有不同，</p>
<h2 id="objectprototypetostringcall">Object.prototype.toString.call()</h2>
<p>这个方法可以说是目前比较全面的类型判断方法了，还是看看例子：</p>
<pre><code class="language-js">Object.prototype.toString.call(null) // &quot;[object Null]&quot;
Object.prototype.toString.call(undefined) // &quot;[object Undefined]&quot;
Object.prototype.toString.call(123) // &quot;[object Number]&quot;
Object.prototype.toString.call(true) // &quot;[object Boolean]&quot;
Object.prototype.toString.call('Hellow world !') // &quot;[object String]&quot;
Object.prototype.toString.call({ a: 123 }) // &quot;[object Object]&quot;
Object.prototype.toString.call(Symbol()) // &quot;[object Symbol]&quot;
Object.prototype.toString.call([1, 2, 3]) // &quot;[object Array]&quot;
Object.prototype.toString.call(function a() {}) // &quot;[object Function]&quot;
Object.prototype.toString.call(new Date()) // &quot;[object Date]&quot;
Object.prototype.toString.call(Math) // &quot;[object Math]&quot;
Object.prototype.toString.call(new Set()) // &quot;[object Set]&quot;
Object.prototype.toString.call(new WeakSet()) // &quot;[object WeakSet]&quot;
Object.prototype.toString.call(new Map()) // &quot;[object Map]&quot;
Object.prototype.toString.call(new WeakMap()) // &quot;[object WeakMap]&quot;,/'.lk
</code></pre>
<p>可以说<code>Object.prototype.toString.call()</code>在大部分类型的考验下都不落下风，可以说是比较完美的类型检查了。<br>
至于原理大家可以移步至<a href="https://segmentfault.com/a/1190000009407558">谈谈 Object.prototype.toString</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浅拷贝没那么简单]]></title>
        <id>https://brownhu.site/post/shallow-copy</id>
        <link href="https://brownhu.site/post/shallow-copy">
        </link>
        <updated>2018-07-20T09:45:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="拷贝的分类">拷贝的分类</h2>
<ol>
<li>浅拷贝： 只能对基本类型的值拷贝，如果所要拷贝的对象的某个属性的值是对象的话，那么目标对象拷贝得到的是这个对象的引用。</li>
<li>深拷贝： 和原对象一样的属性和原型，相互之间互不影响（不一样的内存地址）</li>
</ol>
<p>在写这篇博客之前，看了很多博客实现的浅拷贝，发现大家实现的方法或多或少都有些不足，今天就把这些坑说一说。</p>
<ul>
<li>我需不需要拷贝原对象的原型？</li>
<li>对象中有以Symbol为属性名的属性我需不需要拷贝？</li>
<li>对象中有不可遍历的属性，我要不要拷贝？</li>
</ul>
<h2 id="逐个属性遍历es6之前">逐个属性遍历（ES6之前）</h2>
<p>通过逐个遍历对象的属性并复制，来实现浅拷贝，但这种方法有两个弊端：</p>
<ul>
<li>不可遍历以symbol为属性名的属性</li>
<li>不可遍历不可枚举属性</li>
</ul>
<blockquote>
<p>Symbol 作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。</p>
</blockquote>
<pre><code class="language-js">// 浅拷贝函数
function shallowClone(obj) {
    const newObj = {};
    for (let i in obj) {
        newObj[i] = obj[i];
    }
    return newObj;
}
// 被拷贝对象
const obj1 = {
    a: 1,
    b: 'hellow world',
    c: true,
    d: Symbol('symbol'),
    [Symbol('e')]: 'e',
}
Object.defineProperty(obj1, 'f', {
  value: 'f',
  enumerable: false,
}) // 添加不可枚举属性
const obj2 = shallowClone(obj1);

obj2 // {a: 1, b: &quot;hellow world&quot;, c: true, d: Symbol(symbol)}
</code></pre>
<p>所拷贝的对象并没有以symbol为属性名的属性，也不能拷贝不可遍历的属性，所以这种方法并不是最佳实践。</p>
<h2 id="es6下的浅拷贝">ES6下的浅拷贝</h2>
<p>ES6新增了许多操作对象或者遍历对象的API，下面分别测试下能不能实现完美的浅拷贝</p>
<h3 id="objectassign"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign()</a></h3>
<p>通过和空对象合并来实现浅拷贝：</p>
<pre><code class="language-js">const obj1 = {
    a: 1,
    b: 'hellow world',
    c: true,
    d: Symbol('symbol'),
    [Symbol('e')]: 'e',
}
const obj2 = Object.assign({},obj1) // ES6新扩展： Object.assign() 
obj2 // {a: 1, b: &quot;hellow world&quot;, c: true, d: Symbol(symbol), Symbol(e): &quot;e&quot;}
</code></pre>
<p>发现可以实现对以symbol为属性名的属性的拷贝，但是对于不可枚举属性<code>Object.assign()</code>还是无能为力。 我们在MDN上发现<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign()</a>不可以遍历出不可枚举属性：</p>
<blockquote>
<p>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p>
</blockquote>
<h3 id="解构赋值rest">解构赋值+rest</h3>
<p>那我们看看更加优雅的解构赋值+rest能不能实现完美的浅克隆通过ES6的解构赋值可以更简单的实现浅拷贝：</p>
<pre><code class="language-js">const obj1 = {
    a: 1,
    b: 'hellow world',
    c: true,
    d: Symbol('symbol'),
    [Symbol('e')]: 'e',
}
Object.defineProperty(obj1, 'f', {
  value: 'f',
  enumerable: false,
});
let { ...obj2 } = obj1
obj2 // {a: 1, b: &quot;hellow world&quot;, c: true, d: Symbol(symbol), Symbol(e): &quot;e&quot;}
</code></pre>
<p>发现依然不能解决不可遍历属性的问题。</p>
<h2 id="es7下的浅拷贝">ES7下的浅拷贝</h2>
<h3 id="objectgetownpropertydescriptors"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor">Object.getOwnPropertyDescriptors</a></h3>
<blockquote>
<p><code>Object.getOwnPropertyDescriptor()</code> 方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）</p>
</blockquote>
<p><code>Object.getOwnPropertyDescriptors</code>方法可以配合<code>Object.create</code>方法实现浅拷贝:</p>
<pre><code class="language-js">const shallowClone = (obj) =&gt; Object.create(
    Object.getPrototypeOf(obj),
    Object.getOwnPropertyDescriptors(obj)
);
const obj1 = {
    a: 1,
    b: 'hellow world',
    c: true,
    d: Symbol('symbol'),
    [Symbol('e')]: 'e',
}
Object.defineProperty(obj1, 'f', {
    value: 'f',
    enumerable: false,
});
const obj2 = shallowClone(obj1);

obj2 //{a: 1, b: &quot;hellow world&quot;, c: true, d: Symbol(symbol), f: &quot;f&quot;}
</code></pre>
<p>基本上完美实现了对所有类型属性的拷贝，可以看见即使是浅拷贝，要踩得坑还是很多的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[跨域方法整理]]></title>
        <id>https://brownhu.site/post/cors</id>
        <link href="https://brownhu.site/post/cors">
        </link>
        <updated>2018-06-03T09:55:34.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://images.unsplash.com/photo-1547489026-3228fbcb1664?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1200&amp;h=500&amp;fit=crop&amp;ixid=eyJhcHBfaWQiOjF9" alt=""></figure>
<h2 id="什么是同源">什么是同源</h2>
<p>为了防止网站被 XSS、CSRF 攻击，Netscape 公司在 1995 年引入同源策略/SOP(Same origin policy),它是指“协议+域名+端口”三者相同。</p>
<h2 id="什么是跨域">什么是跨域</h2>
<p>其实就是在违反了同源策略的情况下请求到资源的行为就是跨域，也就是说当协议、域名、端口号有一个或者多个不同时获取数据就是跨域。</p>
<p>在同源限制下 cookie localStorage dom ajax IndexDB 都不支持跨域。</p>
<p>另外，所谓同源策略并不是说在非同源的情况下服务器不返回数据，而是返回的数据被浏览器拦截了。</p>
<h2 id="跨域的几种实现">跨域的几种实现</h2>
<h3 id="jsonp">jsonp</h3>
<pre><code class="language-js">// 封装 jsonp 跨域请求的方法
function jsonp({ url, params, callBack }) {
    return new Promise((resolve, reject) =&gt; {
        // 创建一个 script 标签帮助我们发送请求
        let script = document.createElement('script')
        let arr = []
        params = { ...params, callBack }

        // 循环构建键值对形式的参数
        for (let key in params) {
            arr.push(`${key}=${params[key]}`)
        }

        // 创建全局函数
        window[callBack] = function(data) {
            resolve(data)
            // 在跨域拿到数据以后将 script 标签销毁
            document.body.removeChild(script)
        }

        // 拼接发送请求的参数并赋值到 src 属性
        script.src = `${url}?${arr.join('&amp;')}`
        document.body.appendChild(script)
    })
}

// 调用方法跨域请求百度搜索的接口
json({
    url: 'https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su',
    params: {
        wd: 'jsonp',
    },
    callBack: 'show',
}).then((data) =&gt; {
    // 打印请求回的数据
    console.log(data)
})
</code></pre>
<p><strong>缺点：</strong></p>
<ul>
<li>只支持 get</li>
<li>不安全，容易引发 xss 攻击，别人有可能在返回的结果中返回恶意代码</li>
</ul>
<h3 id="cors">CORS</h3>
<p>跨源资源共享/CORS（Cross-Origin Resource Sharing）是 W3C 的一个工作草案，定义了在必须访问跨源资源时，浏览器与服务器应该如何沟通。CORS 背后的基本思想，就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。</p>
<p>浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<p>简单请求必须要满足两个条件：</p>
<ol>
<li>请求方法：</li>
</ol>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<ol start="2">
<li>HTTP 头信息不超出以下字段</li>
</ol>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用requestAnimationFrame来提升动画性能]]></title>
        <id>https://brownhu.site/post/requestanimationframe</id>
        <link href="https://brownhu.site/post/requestanimationframe">
        </link>
        <updated>2018-05-20T09:42:21.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://user-gold-cdn.xitu.io/2018/5/20/1637ddf84e9110d6?w=550&amp;h=365&amp;f=jpeg&amp;s=59063" alt=""></figure>
<h2 id="传统动画的弊端">传统动画的弊端</h2>
<p>在实际项目中我们经常会遇到生成动画的需求，传统方法是通过使用setTimeout和setInterval进行实现，但是定时器动画有两个弊端：</p>
<ul>
<li>时间间隔并不好拿捏，设置太短浏览器重绘频率太快会产生性能问题，太慢的话又显得像PPT不够平滑，业界推荐的时间间隔是16.66...（显示器刷新频率是60Hz，1000ms/60）</li>
<li>浏览器UI线程堵塞问题，如果UI线程之中有很多待完成的渲染任务，所要执行的动画就会被搁置。</li>
</ul>
<p>为了解决这些问题HTML5加入了requestAnimationFrame</p>
<h2 id="requestanimationframe">requestAnimationFrame？</h2>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame">MDN</a></p>
<blockquote>
<p>window.requestAnimationFrame() 方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。</p>
</blockquote>
<ul>
<li>
<p>requestAnimationFrame会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率</p>
</li>
<li>
<p>在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的CPU、GPU和内存使用量</p>
</li>
<li>
<p>requestAnimationFrame是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销</p>
</li>
</ul>
<h2 id="用法">用法</h2>
<p>你可以直接调用<code>requestAnimationFrame()</code>，也可以通过window来调用<code>window.requestAnimationFrame()</code>。<br>
requestAnimationFrame()接收一个函数作为回调，返回一个ID值，通过把这个ID值传给<code>window.cancelAnimationFrame()</code>可以取消该次动画。</p>
<p>MDN上给的例子：</p>
<pre><code class="language-js">var start = null;
var element = document.getElementById('SomeElementYouWantToAnimate');
element.style.position = 'absolute';

function step(timestamp) {
  if (!start) start = timestamp;
  var progress = timestamp - start;
  element.style.left = Math.min(progress / 10, 200) + 'px';
  if (progress &lt; 2000) {
    window.requestAnimationFrame(step);
  }
}
</code></pre>
<h2 id="例子">例子</h2>
<p>我们来试试生成一个旋转并逐渐变窄的方块，当窄到一定程度又会复原循环往复。<br>
<a href="http://jsbin.com/xeferik/3/edit?js,output">jsbin看看效果</a></p>
<pre><code class="language-js">var rotate = 0;
var width = 400;
var element = document.getElementById('box');

function step(timestamp) {
    rotate += 10
    element.style.transform = `rotate(${rotate}deg)`;
    window.requestAnimationFrame(step);
}

function small(timestamp) {
    width = width - 1
    element.style.width = width + 'px';
    if (width &lt;= 50) {
        window.requestAnimationFrame(big);
    } else {
        window.requestAnimationFrame(small);
    }
}
function big() {
    width = width + 1
    element.style.width = width + 'px';
    if (width &gt;= 400) {
        window.requestAnimationFrame(small);
    } else {
        window.requestAnimationFrame(big);
    }
}

window.requestAnimationFrame(step);
window.requestAnimationFrame(small);
</code></pre>
<h2 id="浏览器兼容情况">浏览器兼容情况</h2>
<p>我们来看一下[Can I Use](https://caniuse.com/## search=requestAnimationFrame)上的兼容情况：<br>
<img src="https://user-gold-cdn.xitu.io/2018/5/20/1637d6be4df448ce?w=1718&amp;h=781&amp;f=png&amp;s=80112" alt=""><br>
requestAnimationFrame的兼容情况还是不错的（看不见IE）</p>
<p>如果非要兼容IE的话可以用定时器来做一下兼容：</p>
<pre><code class="language-js">(function () {
    var lastTime = 0;
    var vendors = ['webkit', 'moz'];
    for (var x = 0; x &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
        window.cancelAnimationFrame =
            window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
    }

    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = function (callback) {
            /*调整时间，让一次动画等待和执行时间在最佳循环时间间隔内完成*/
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function () {
                callback(currTime + timeToCall);
            },
                timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };

    if (!window.cancelAnimationFrame)
        window.cancelAnimationFrame = function (id) {
            clearTimeout(id);
        };
}());
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[排序算法-N个正整数排序]]></title>
        <id>https://brownhu.site/post/sort</id>
        <link href="https://brownhu.site/post/sort">
        </link>
        <updated>2018-05-09T09:46:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="算法">算法</h2>
<p>高德纳在《计算机程序设计艺术》里对算法归纳为以下几点：</p>
<blockquote>
<ol>
<li>输入: 一个算法必须有零或以上的输入量</li>
<li>输出: 一个算法应有一个或以上的输出量</li>
<li>明确性: 算法的描述必须无歧义,实际运行结果是确定的</li>
<li>有限性: 必须在有限个步骤内结束</li>
<li>有效性: 又称可行性,能够被执行者实现</li>
</ol>
</blockquote>
<p><strong>如果想详细研究算法推荐《数据结构与算法分析》</strong></p>
<figure data-type="image" tabindex="1"><img src="http://upload-images.jianshu.io/upload_images/4337988-706bb05d7f8e293f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据结构与算法分析"></figure>
<h2 id="定义问题">定义问题</h2>
<p>数组array含有N个正整数<br>
输入量为array<br>
请将array中的数字从小到大排列<br>
输出量为排好序的数组</p>
<p>代码例子</p>
<pre><code class="language-js">var array = [5,2,4,6,8]
function sort(){
   你的代码
}
sort(array) === [2,4,5,6,8]
</code></pre>
<p>当你遇到思路障碍怎么办?</p>
<ul>
<li>将<strong>抽象的问题</strong>转化为<strong>具体的问题</strong></li>
<li>将<strong>没见过的问题</strong>转化为<strong>见过的问题</strong></li>
</ul>
<h2 id="排序算法">排序算法</h2>
<p><strong><a href="https://visualgo.net/sorting">所有算法都可在此查看演示</a></strong></p>
<h3 id="冒泡排序bubble">冒泡排序(BUBBLE)</h3>
<p>重复地比较要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。比较数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。每比较一整轮,最大的都会出现在最后故名---<strong>冒泡排序</strong></p>
<p>流程如下:</p>
<ol>
<li>我们拿到一个数组<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-51788201338ecebb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数组"></li>
<li>开始从前两个开始比较,发现44&gt;3,所以不用交换<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-27cf4ee44274aebd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="比较"></li>
<li>接着往后比较,发现38&lt;44,所以交换他们两个的位置<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-b106c8ea4d1e64a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="比较"></li>
<li>以此类推直到第一轮结束,我们得到了最大的那一个----<strong>50</strong>(冒的第一个泡)<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-05228b4f061ec01b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第一轮结束"></li>
<li>接着下一轮,又从头开始两个两个地比较,重复第一轮,我们就得到了第二个最大的------<strong>48</strong><br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-b3a220becd934a11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第二轮结束"></li>
<li>如此进行多轮比较我们会得到一个从小到大的数组<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-f60c295026eac0f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="从小到大"></li>
<li>代码实现：</li>
</ol>
<pre><code class="language-js">function bubbleSort(array) {
    for (let i = 0; i &lt; array.length - 1; i++) {
        for (let j = 0; j &lt; array.length - i - 1; j++) {
            if (array[j] &gt; array[j + 1]) {
                let temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
            }
        }
    }
}
</code></pre>
<h3 id="2-选择排序select">2. 选择排序(SELECT)</h3>
<p>每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。<br>
流程如下:</p>
<ol>
<li>拿到一个数组<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-62f83dc193f1978c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数组"></li>
<li>我们要选出这个数组中最小的元素然后把它和第一个数交换(放到最前面),所以我们先认为3为最小,然后和后面的数依次进行比较.<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-b44dc333bdadd03b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="和最小值比较"></li>
<li>当比到2的时候,我们发现3&gt;2,所以我们就认为2为最小值,后面的数应该都和2进行比较.<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-47bda740993e028c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="改变最小值的元素"></li>
<li>当比较完所有的元素,确定2为最小值的时候,把最小值也就是2与第一个元素的位置互换.<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-549ba8d1e5375edd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="互换位置"></li>
<li>然后从第二个元素开始新一轮的比较,过程和第一轮一样.把44看做最小值和后面的元素进行比较.<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-93ae5c6008503d42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第二轮"></li>
<li>经过多轮比较得到从小到大的数组.<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-10b714a8ceceb65f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="从小到大"></li>
<li>代码实现</li>
</ol>
<pre><code class="language-js">function selectSort(arr) {
    var minIndex, temp;
    for (let i = 0; i &lt; arr.length - 1; i++) {
        minIndex = i; // 先把第一个看做最小值
        for (let j = i + 1; j &lt; arr.length; j++) {
            if (arr[j] &lt; arr[minIndex]) {
                minIndex = j;
            }
        }
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    return arr;
}
</code></pre>
<h3 id="3-插入排序insert">3, 插入排序(INSERT)</h3>
<p>将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序。是稳定的排序方法。<br>
流程如下:</p>
<ol>
<li>拿到一个数组<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-0fe1ff7bc8912789.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数组"></li>
<li>把第一个元素看做一个新数组,然后把第二个元素依次和新数组的元素进行比较(虽然只有一个...),然后插入到适当的位置.<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-0b049542a383e8dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="与新数组的元素进行比较"><br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-b08f38982e74bf87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="插入到适当的位置"></li>
<li>然后以此类推,把前两个元素看做是一个新数组,然后把第三个元素依次与新数组进行比较,然后插入到适当的位置.<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-25293f6061257350.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="比较"><br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-435373ab53226a01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="插入适当的位置"></li>
<li>把剩下的元素依次插入,最后得到从小到大排列的数组.<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-eb5c7cdc2dbe51e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="从小到大"></li>
<li>代码实现</li>
</ol>
<pre><code class="language-js">function insertionSort(array) {
    for (let i = 1; i &lt; array.length; i++) {
        let key = array[i];
        let j = i - 1;
        while (j &gt;= 0 &amp;&amp; array[j] &gt; key) {
            array[j + 1] = array[j];
            j--;
        }
        array[j + 1] = key;
    }
    return array;
}
</code></pre>
<h3 id="4-归并排序merge">4. 归并排序(MERGE)</h3>
<p>将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。<br>
流程如下:</p>
<ol>
<li>拿到一个数组<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-b7dd0bc29bf1f856.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数组"></li>
<li>我们把数组平均分成左右两部分,得到两个新数组,然后再把每个数组平均分成两部分,一直分到每个数组只有两个元素,然后比较第一组<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-f1f922e5fdac37ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="比较第一组"></li>
<li>因为3&lt;44所以位置不变然后比较第二组,因为38&gt;5所以调换位置.<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-82e45b17bd304d2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片.png"></li>
<li>重点来了,这个时候先不着急比较第三组而是把排好序的一二两组放在一起排序.<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-a45b23e96799adbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片.png"></li>
<li>之后就是比较第三组和第四组,然后同样把他们放在一起排好序.<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-ada3c8eb5b769b9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片.png"></li>
<li>然后并不是比较第五组和第六组,而是把第一组和第二组产生的新数组和,第三组和第四组产生的新数组放在一起排序成为新数组.<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-7df965288165ac01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片.png"></li>
<li>同样把剩下的按以上步骤重来一遍.我们得到两个排好序的数组.然后给这两个数组排序就完成了.<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-3e92a52343a0d8c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片.png"><br>
排序后:<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-78eebc9c38d1ba31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片.png"></li>
<li>代码实现</li>
</ol>
<pre><code class="language-js">function mergeSort(arr) {
    var len = arr.length;
    if (len &lt; 2) {
        return arr;
    }
    var middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right) {
    var result = [];

    while (left.length &amp;&amp; right.length) {
        if (left[0] &lt;= right[0]) {
            result.push(left.shift());
        } else {
            result.push(right.shift());
        }
    }

    while (left.length)
        result.push(left.shift());
    while (right.length)
        result.push(right.shift());

    return result;
}
</code></pre>
<h3 id="5-快速排序">5. 快速排序</h3>
<p>每个元素找到自己对应的位置(前面的都比我小,后面的都比我大)<br>
流程如下:</p>
<ol>
<li>拿到一个数组<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-b7dd0bc29bf1f856.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数组"></li>
<li>拿第一个元素和后面的元素进行比较,找出所有比第一个元素小的元素,放在第一个元素的右边然后把第一个元素与这些比他小的元素的最后一个互换.<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-ce0718ea693d000a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="只有2比3小"><br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-e7742e9a14f46e1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="互换"></li>
<li>前两个元素的位置已经没错了,然后以第三个元素为标准,和后面的元素进行比较.<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-e51bf6b6f28eccf0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="比较之后"></li>
<li>把比他小的元素放在他的右边(绿色),然后让它和绿色的最后一个交换位置.<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-9635a1d9604436b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="交换位置"></li>
<li>然后从左边没有确定位置的元素(非橙色)开始以上步骤----也就是19<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-b3888a1ab15ac163.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="从19开始"></li>
<li>一直到所有元素的位置都正确.<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-782962d8fbda2a3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="都有了正确的位置"></li>
<li>代码实现</li>
</ol>
<pre><code class="language-js">function quickSort(array) {
    function quick(array, left, right) {
        let index;
        if (array.length &gt; 1) {
            index = partition(array, left, right);
            if (left &lt; index - 1) {
                quick(array, left, index - 1);
            }
            if (index &lt; right) {
                quick(array, index, right);
            }
        }
        return array;
    }
    function partition(array, left, right) {
        const pivot = array[Math.floor((right + left) / 2)];
        let i = left;
        let j = right;
    
        while (i &lt;= j) {
            while (array[i] &lt; pivot) {
                i++;
            }
            while (array[j] &gt; pivot) {
                j--;
            }
            if (i &lt;= j) {
                [array[i], array[j]] = [array[j], array[i]]
                i++;
                j--;
            }
        }
        return i;
    }
    quick(array, 0, array.length - 1);
};
</code></pre>
<h3 id="6-随机快速排序">6. 随机快速排序</h3>
<p>顾名思义,就是在快速排序的基础上,加入随机的机制.<br>
在快速排序的时候我们是从左到右来选取比较对象,在随机快速排序中我们是随机来选取对象.<br>
流程如下:</p>
<ol>
<li>拿到一个数组<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-b7dd0bc29bf1f856.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数组"></li>
<li>随机选择一个元素.<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-068de5de14fbba31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="随机选择到了44"></li>
<li>并且把比他小的放在他的右边<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-903e43f47d9288a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="把比他小的先放在他的右边"></li>
<li>然后把他和比他小的最右边的元素交换位置<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-9716186d31f495f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="交换位置"></li>
<li>然后在随机选一个元素,重复步骤,知道所有元素都是在正确的位置上.<br>
<img src="http://upload-images.jianshu.io/upload_images/4337988-5eed2e2fa3aaf364.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="所有元素都在正确的位置上"></li>
<li>代码实现</li>
</ol>
<pre><code class="language-js">function quickSort(array) {
    function quick(array, left, right) {
        let index;
        if (array.length &gt; 1) {
            index = partition(array, left, right);
            if (left &lt; index - 1) {
                quick(array, left, index - 1);
            }
            if (index &lt; right) {
                quick(array, index, right);
            }
        }
        return array;
    }
    function partition(array, left, right) {
        const pivot = array[Math.floor(Math.random()*array.length)];
        let i = left;
        let j = right;
    
        while (i &lt;= j) {
            while (array[i] &lt; pivot) {
                i++;
            }
            while (array[j] &gt; pivot) {
                j--;
            }
            if (i &lt;= j) {
                [array[i], array[j]] = [array[j], array[i]]
                i++;
                j--;
            }
        }
        return i;
    }
    quick(array, 0, array.length - 1);
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hexo已经看腻了，来试试VuePress搭建个人博客]]></title>
        <id>https://brownhu.site/post/vuepress</id>
        <link href="https://brownhu.site/post/vuepress">
        </link>
        <updated>2018-04-23T09:17:23.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://user-gold-cdn.xitu.io/2018/4/23/162f21a0e09d9fd3?w=600&amp;h=600&amp;f=png&amp;s=160672" alt=""></figure>
<h2 id="vuepress">VuePress</h2>
<p>先简单介绍一下VuePress，这是尤大在2018年4月份发布的一个新轮子。</p>
<figure data-type="image" tabindex="2"><img src="https://user-gold-cdn.xitu.io/2018/4/23/162f21add3603e86?w=751&amp;h=418&amp;f=png&amp;s=63447" alt=""></figure>
<p>一个基于 Vue SSR 的静态站生成器，本来的目的是爽爽的写文档，但是我发现用来撸一个人博客也非常不错。</p>
<p><strong><a href="https://vuepress.vuejs.org/">这是VuePress的官方文档</a></strong><br>
<strong><a href="https://vuepress.docschina.org/">这是VuePress的中文文档</a></strong></p>
<h2 id="上手搭建">上手搭建</h2>
<p>你可以跟着文档上的例子自己玩一玩，不过由于VuePress的文档也是用VuePress来实现的，所以我取巧直接拿<a href="https://github.com/vuejs/vuepress">VuePress仓库</a>中的<strong>docs</strong>目录拿来玩耍。</p>
<ol>
<li>首先安装VuePress到全局</li>
</ol>
<pre><code class="language-bash">npm install -g vuepress
</code></pre>
<ol start="2">
<li>然后把VuePress仓库克隆到你的电脑</li>
</ol>
<pre><code class="language-bash">git clone git@github.com:docschina/vuepress.git
</code></pre>
<ol start="3">
<li>在docs文件中执行（请确保你的 Node.js 版本 &gt;= 8）</li>
</ol>
<pre><code class="language-bash">cd vuepress
cd docs
vuepress dev
</code></pre>
<p>当你看到这一行就说明已经成功了：</p>
<pre><code> VuePress dev server listening at http://localhost:8080/
</code></pre>
<p>下面我们打开<a href="http://localhost:8080/">http://localhost:8080/</a><br>
发现真的打开了vuepress文档：<br>
<img src="https://user-gold-cdn.xitu.io/2018/4/23/162f21a0e0944215?w=1240&amp;h=520&amp;f=png&amp;s=69295" alt=""></p>
<p>下面的工作就是数据的替换了，但我们应该先看一下docs的目录结构：</p>
<pre><code>├─.vuepress
│  ├─components
│  └─public
│      └─icons
│   └─config.js // 配置文件
├─config // Vuepress文档的配置参考内容
├─default-theme-config // Vuepress文档的默认主题配置内容
├─guide // Vuepress文档的指南内容
└─zh // 中文文档目录
    ├─config
    ├─default-theme-config
    └─guide
└─README.md // 首页配置文件
</code></pre>
<p>文档分成了两部分，中文文档在/zh/目录下，英文文档在根目录下。</p>
<p>其实目录里面的东西都挺好看懂的，首先guide 、default-theme-config、config 这三个目录中的都是Vuepress文档的主要内容，从中文文档里也可以看到只有这三个目录被替换了。</p>
<h2 id="首页配置">首页配置</h2>
<p>默认主题提供了一个主页布局，要使用它，需要在你的根目录 <code>README.md</code> 的 <a href="https://vuepress.docschina.org/guide/markdown.html#yaml-front-matter">YAML front matter</a> 中指定 <code>home：true</code>，并加上一些其他的元数据。</p>
<p>我们先看看根目录下的README,md：</p>
<pre><code>home: true // 是否使用Vuepress默认主题
heroImage: /hero.png // 首页的图片
actionText: Get Started →  // 按钮的文字
actionLink: /guide/ // 按钮跳转的目录
features: // 首页三个特性
- title: Simplicity First
  details: Minimal setup with markdown-centered project structure helps you focus on writing.
- title: Vue-Powered
  details: Enjoy the dev experience of Vue + webpack, use Vue components in markdown, and develop custom themes with Vue.
- title: Performant
  details: VuePress generates pre-rendered static HTML for each page, and runs as an SPA once a page is loaded.
footer: MIT Licensed | Copyright © 2018-present Evan You // 页尾
</code></pre>
<p>实在看不懂，<a href="https://vuepress.docschina.org/default-theme-config/">官网</a>有比我更详细的配置说明。</p>
<h2 id="导航配置">导航配置</h2>
<p>导航配置文件在<code>.vuepress/config.js</code>中</p>
<p>在导航配置文件中nav是控制导航栏链接的，你可以把它改成自己的博客目录。</p>
<pre><code class="language-js">nav: [
    {
        text: 'Guide',
        link: '/guide/',
    },
    {
        text: 'Config Reference',
        link: '/config/'
    },
    {
        text: 'Default Theme Config',
        link: '/default-theme-config/'
    }
]
</code></pre>
<p>剩下的默认主题配置官方文档都有很详细的文档说明这里就不在啰嗦了。</p>
<h2 id="更改默认主题色">更改默认主题色</h2>
<p>你可以在<code>.vuepress/</code>目录下创建一个<code>override.styl</code>文件。<br>
vuepress提供四个可更改的颜色：</p>
<pre><code>$accentColor = #3eaf7c // 主题色
$textColor = #2c3e50 // 文字颜色
$borderColor = #eaecef // 边框颜色
$codeBgColor = #282c34 // 代码背景颜色
</code></pre>
<p>我把它改成了这样：<br>
<img src="https://user-gold-cdn.xitu.io/2018/4/23/162f21a0e07ec947?w=1240&amp;h=698&amp;f=png&amp;s=138334" alt=""></p>
<h2 id="侧边栏的实现">侧边栏的实现</h2>
<p>由于评论区里问的人较多，所以在这里更新一下，其实我就算在这里写的再详细也不如大家去看官方文档。<br>
侧边栏的配置也在<code>.vuepress/config.js</code>中：</p>
<pre><code>sidebar: [
  {
    title: 'JavaScript', // 侧边栏名称
    collapsable: true, // 可折叠
    children: [
      '/blog/JavaScript/学会了ES6，就不会写出那样的代码', // 你的md文件地址
    ]
  },
  {
    title: 'CSS', 
    collapsable: true,
    children: [
      '/blog/CSS/搞懂Z-index的所有细节',
    ]
  },
  {
    title: 'HTTP',
    collapsable: true,
    children: [
      '/blog/HTTP/认识HTTP-Cookie和Session篇',
    ]
  },
]
</code></pre>
<p>对应的文档结构：</p>
<pre><code>├─blog // docs目录下新建一个博客目录
│  ├─CSS
│  ├─HTTP
│  └─JavaScript
</code></pre>
<p>我的博客：<a href="http://brownhu.site/">brownhu</a></p>
<h2 id="部署">部署</h2>
<p>在配置好你博客之后，命令行执行：</p>
<pre><code class="language-bash">Vuepress build
</code></pre>
<p>当你看到这一行就说明成功了：</p>
<pre><code>Success! Generated static files in vuepress.
</code></pre>
<p>将打包好的vuepress目录上传到你的github仓库，和github page配合，就可以配置好你的博客网站了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[学会了ES6，就不会写出那样的代码]]></title>
        <id>https://brownhu.site/post/es6</id>
        <link href="https://brownhu.site/post/es6">
        </link>
        <updated>2018-04-09T09:41:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="声明变量的新姿势">声明变量的新姿势</h2>
<h3 id="用let不用var">用let不用var</h3>
<p>ES6之前我们用var声明一个变量，但是它有很多弊病：</p>
<ul>
<li>因为没有块级作用域，很容易声明全局变量</li>
<li>变量提升</li>
<li>可以重复声明 还记得这道面试题吗？</li>
</ul>
<pre><code class="language-js">var a = [];
for (var i = 0; i &lt; 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 10
a[7](); // 10
a[8](); // 10
a[9](); // 10
</code></pre>
<p>所以，你现在还有什么理由不用let?</p>
<h3 id="有时候const比let更好">有时候const比let更好</h3>
<p>const和let的唯一区别就是，const不可以被更改，所以当声明变量的时候，尤其是在声明容易被更改的全局变量的时候，尽量使用const。</p>
<ul>
<li>更好的代码语义化，一眼看到就是常量。</li>
<li>另一个原因是因为JavaScript 编译器对const的优化要比let好，多使用const，有利于提高程序的运行效率。</li>
<li>所有的函数都应该设置为常量。</li>
</ul>
<h2 id="动态字符串">动态字符串</h2>
<p>不要使用“双引号”，一律用单引号或反引号</p>
<pre><code class="language-js">// low
const a = &quot;foobar&quot;;
const b = 'foo' + a + 'bar';

// best
const a = 'foobar';
const b = `foo${a}bar`;
const c = 'foobar';
</code></pre>
<h2 id="解构赋值的骚操作">解构赋值的骚操作</h2>
<h3 id="变量赋值">变量赋值</h3>
<p>在用到数组成员对变量赋值时，尽量使用解构赋值。</p>
<pre><code class="language-js">const arr = [1, 2, 3, 4];

// low
const first = arr[0];
const second = arr[1];

// good
const [first, second] = arr;
</code></pre>
<h3 id="函数传对象">函数传对象</h3>
<p>函数的参数如果是对象的成员，优先使用解构赋值。</p>
<pre><code class="language-js">// low
function getFullName(user) {
  const firstName = user.firstName;
  const lastName = user.lastName;
}

// good
function getFullName({ firstName, lastName }) {
}
</code></pre>
<p>如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。</p>
<pre><code class="language-js">// low
function processInput(input) {
  return [left, right, top, bottom];
}

// good
function processInput(input) {
  return { left, right, top, bottom };
}

const { left, right } = processInput(input);
</code></pre>
<h2 id="关于对象的细节">关于对象的细节</h2>
<h3 id="逗号">逗号</h3>
<p>单行定义的对象结尾不要逗号：</p>
<pre><code class="language-js">// low
const a = { k1: v1, k2: v2, };

// good
const a = { k1: v1, k2: v2 };

</code></pre>
<p>多行定义的对象要保留逗号：</p>
<pre><code class="language-js">// low
const b = {
  k1: v1,
  k2: v2
};

// good
const b = {
  k1: v1,
  k2: v2,
};
</code></pre>
<h3 id="一次性初始化完全">一次性初始化完全</h3>
<p>不要声明之后又给对象添加新属性：</p>
<pre><code class="language-js">// low
const a = {};
a.x = 3;

// good
const a = { x: null };
a.x = 3;
</code></pre>
<p>如果一定非要加请使用<code>Object.assign</code>：</p>
<pre><code class="language-js">const a = {};
Object.assign(a, { x: 3 });
</code></pre>
<p>如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义：</p>
<pre><code class="language-js">// low
const obj = {
  id: 5,
  name: 'San Francisco',
};
obj[getKey('enabled')] = true;

// good
const obj = {
  id: 5,
  name: 'San Francisco',
  [getKey('enabled')]: true,
};
</code></pre>
<h3 id="在简洁一点">在简洁一点</h3>
<p>在定义对象时，能简洁表达尽量简洁表达：</p>
<pre><code class="language-js">var ref = 'some value';

// low
const atom = {
  ref: ref,

  value: 1,

  addValue: function (value) {
    return atom.value + value;
  },
};

// good
const atom = {
  ref,

  value: 1,

  addValue(value) {
    return atom.value + value;
  },
};
</code></pre>
<h2 id="数组">数组</h2>
<h3 id="">...</h3>
<p>使用扩展运算符<code>...</code>拷贝数组：</p>
<pre><code class="language-js">// 还在用for i 你就太low了
const len = items.length;
const itemsCopy = [];
let i;

for (i = 0; i &lt; len; i++) {
  itemsCopy[i] = items[i];
}

// cool !
const itemsCopy = [...items];
</code></pre>
<h3 id="不要跟我提类数组">不要跟我提类数组</h3>
<p>用<code>Array.from</code>方法，将类似数组的对象转为数组：</p>
<pre><code class="language-js">const foo = document.querySelectorAll('.foo');
const nodes = Array.from(foo);
</code></pre>
<h2 id="函数">函数</h2>
<h3 id="箭头函数">箭头函数<code>=&gt;</code></h3>
<p>立即执行函数可以写成箭头函数的形式：</p>
<pre><code class="language-js">(() =&gt; {
  console.log('Welcome to the Internet.');
})();
</code></pre>
<p>尽量写箭头函数使你的代码看起来简洁优雅：</p>
<pre><code class="language-js">// low
[1, 2, 3].map(function (x) {
  return x * x;
});

// cool !
[1, 2, 3].map(x =&gt; x * x);
</code></pre>
<h3 id="不要把布尔值直接传入函数">不要把布尔值直接传入函数</h3>
<pre><code class="language-js">// low
function divide(a, b, option = false ) {
}

// good
function divide(a, b, { option = false } = {}) {
}
</code></pre>
<h3 id="别再用arguments类数组了">别再用arguments（类数组）了！</h3>
<p>使用 rest 运算符（...）代替，rest 运算符可以提供一个真正的数组。</p>
<pre><code class="language-js">// low
function concatenateAll() {
  const args = Array.prototype.slice.call(arguments);
  return args.join('');
}

// good
function concatenateAll(...args) {
  return args.join('');
}
</code></pre>
<h3 id="传参时试试设置默认值">传参时试试设置默认值？</h3>
<pre><code class="language-js">// low
function handleThings(opts) {
  opts = opts || {};
}

// good
function handleThings(opts = {}) {
  // ...
}
</code></pre>
<h2 id="objectmap">Object？Map！</h2>
<h3 id="简单的键值对优先map">简单的键值对优先Map</h3>
<p>如果只是简单的key: value结构，建议优先使用Map，因为Map提供方便的遍历机制。</p>
<pre><code class="language-js">let map = new Map(arr);
// 遍历key值
for (let key of map.keys()) {
  console.log(key);
}
// 遍历value值
for (let value of map.values()) {
  console.log(value);
}
// 遍历key和value值
for (let item of map.entries()) {
  console.log(item[0], item[1]);
}
</code></pre>
<h2 id="更加简洁直观class语法">更加简洁直观class语法</h2>
<pre><code class="language-js">// low
function Queue(contents = []) {
  this._queue = [...contents];
}
Queue.prototype.pop = function() {
  const value = this._queue[0];
  this._queue.splice(0, 1);
  return value;
}

// good
class Queue {
  constructor(contents = []) {
    this._queue = [...contents];
  }
  pop() {
    const value = this._queue[0];
    this._queue.splice(0, 1);
    return value;
  }
}
</code></pre>
<h2 id="模块化">模块化</h2>
<h3 id="引入模块">引入模块</h3>
<p>使用<code>import</code>取代<code>require</code>，因为Module是Javascript模块的标准写法。</p>
<pre><code class="language-js">// bad
const moduleA = require('moduleA');
const func1 = moduleA.func1;
const func2 = moduleA.func2;

// good
import { func1, func2 } from 'moduleA';
</code></pre>
<h3 id="输出模块">输出模块</h3>
<p>使用<code>export</code>输出变量，拒绝<code>module.exports</code>:</p>
<pre><code class="language-js">import React from 'react';

class Breadcrumbs extends React.Component {
  render() {
    return &lt;nav /&gt;;
  }
};

export default Breadcrumbs;
</code></pre>
<ul>
<li>输出单个值，使用<code>export default</code></li>
<li>输出多个值，使用<code>export</code></li>
<li><code>export default</code>与普通的<code>export</code>不要同时使用</li>
</ul>
<h2 id="编码规范">编码规范</h2>
<p>模块输出一个函数，首字母应该小写：</p>
<pre><code class="language-js">function getData() {
}

export default getData;
</code></pre>
<p>模块输出一个对象，首字母应该大写:</p>
<pre><code class="language-js">const Person = {
  someCode: {
  }
};

export default Person ;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用ColorfulImg获取图片主题色！]]></title>
        <id>https://brownhu.site/post/colorfulimg</id>
        <link href="https://brownhu.site/post/colorfulimg">
        </link>
        <updated>2018-03-29T13:23:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="取色网站">取色网站</h2>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/12/165c960c72a38dae?w=1240&amp;h=739&amp;f=png&amp;s=555321" alt=""><br>
前几天遇到了获取图片主题色的需求，于是去找了一些相关的博客，发现实现起来相当简单，于是自己开发了一个获取图片主题色的网站---<a href="https://hubingliang.github.io/colorfulImg/dist/">ColorfulImg</a><br>
大家可以通过上传/拖拽图片的方式获取图片主题色。</p>
<p>欢迎Star~</p>
<h2 id="colorfulimg">ColorfulImg</h2>
<p>Colorfulimg是一个能够通过canvas获取图片主题色的js工具库。</p>
<p>安装：</p>
<p><code>npm i colorfulimg</code></p>
<p>使用方法：</p>
<pre><code class="language-js">let colorfulimg = require('colorfulimg') 
let myImg = document.getElementById('myImg')
let rgb = colorfulImg(myImg);
</code></pre>
<p><a href="https://github.com/hubingliang/colorfulImg">这是项目地址</a></p>
<p>欢迎star~</p>
<h2 id="colorfulimg实现思路">ColorfulImg实现思路</h2>
<p>下面说一下实现思路，主要是通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial">canvas</a>的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData">getImageData()</a>方法获取图片每个像素点的rgba数据。通过取得平均值的方法来算出图片主题色。<br>
所以要想实现此效果有两个限制：</p>
<ul>
<li>网站和图片必须是相同的域名（getImageData()限制图片必须同源）</li>
<li>浏览器必须支持canvas</li>
</ul>
<h3 id="在canvas中绘制img图像">在canvas中绘制img图像</h3>
<ol>
<li>首先我们要新建一个canvas标签并且访问它的绘画上下文：</li>
</ol>
<pre><code class="language-js">let canvas = document.createElement('canvas')
let context = canvas.getContext &amp;&amp; canvas.getContext('2d')
</code></pre>
<ol start="2">
<li>绘制img图像，X轴与Y轴的起始点都设置为0：</li>
</ol>
<pre><code class="language-js">let myImg = document.getElementById('myImg')
context.drawImage(myImg , 0, 0)
</code></pre>
<h3 id="获取图片颜色数据getimagedata">获取图片颜色数据getImageData()</h3>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData">getImageData()</a>这个API需要四个参数，前两个是获取图片数据的起点，后两个是提取的图像数据矩形区域的宽度和高度，我们要得到图片全部的数据所以后两个参数就是图片的宽高，于此同时我们也要把canvas的宽高设置为图片的宽高能完全装下图片。</p>
<pre><code class="language-js">let height = canvas.height = imgEl.height
let width = canvas.width = imgEl.width
let data = context.getImageData(0, 0, width, height).data
</code></pre>
<p>在我第一次测试的时候遇到了跨域的问题：</p>
<figure data-type="image" tabindex="1"><img src="https://user-gold-cdn.xitu.io/2018/9/12/165c960c72b06536?w=631&amp;h=171&amp;f=png&amp;s=9973" alt=""></figure>
<p>图片如果不同源的话必须要加<code>crossorigin=&quot;anonymous&quot;</code>的属性，并且服务器存储那边也要开放相应的权限才行。<br>
<code>&lt;img id=&quot;img&quot; crossorigin=&quot;anonymous&quot;&gt;</code></p>
<h3 id="处理获取的颜色数据">处理获取的颜色数据</h3>
<p>我们先log一下拿到的数据是什么吧：</p>
<figure data-type="image" tabindex="2"><img src="https://user-gold-cdn.xitu.io/2018/9/12/165c960c72cc7c75?w=631&amp;h=295&amp;f=png&amp;s=9846" alt=""></figure>
<p>是一个有着一堆数据的数组，这些数据是什么呢？我们先看一下MDN：</p>
<figure data-type="image" tabindex="3"><img src="https://user-gold-cdn.xitu.io/2018/9/12/165c960c72e4542f?w=773&amp;h=120&amp;f=png&amp;s=15815" alt=""></figure>
<p>也就是说按顺序来看前四位组成一个以RGBA顺序的数据：<br>
<strong>rgba(red, green, blue, alpha)</strong></p>
<p>对于获取的图片数据透明度（alpha）都是255也就是不透明的所以我们不对透明度做处理，之后我们只需要把rgb的其他三个值分别求和再取均值就可以得到图片的主题色了！</p>
<pre><code class="language-js">let count = 0
let i = 0
let blockSize = 1
while ( (i += blockSize * 4) &lt; length ) {
  ++count
  rgb.r = data[i] + rgb.r 
  rgb.g = data[i+1] + rgb.g
  rgb.b = data[i+2] + rgb.b
}
rgb.r = ~~(rgb.r/count)
rgb.g = ~~(rgb.g/count)
rgb.b = ~~(rgb.b/count)
</code></pre>
<h3 id="最终代码">最终代码</h3>
<pre><code class="language-js">function colorfulImg(img){
    let canvas = document.createElement('canvas'),
        context = canvas.getContext &amp;&amp; canvas.getContext('2d'),
        height,width,length,data, 
        i = -4,
        blockSize = 5,
        count = 0,
        rgb = {r:0,g:0,b:0}
            
    height = canvas.height = imgEl.height
    width = canvas.width = imgEl.width
    context.drawImage(imgEl, 0, 0);
    data = context.getImageData(0, 0, width, height).data
    length = data.length
    while ( (i += blockSize * 4) &lt; length ) {
    ++count;
    rgb.r += data[i];
    rgb.g += data[i+1];
    rgb.b += data[i+2];
    }
    rgb.r = ~~(rgb.r/count);
    rgb.g = ~~(rgb.g/count);
    rgb.b = ~~(rgb.b/count);
    return rgb;
}
</code></pre>
]]></content>
    </entry>
</feed>