<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>可能是最全的 Javascript 类型检查方案 | Gridea</title>
<link rel="shortcut icon" href="https://hubingliang.github.io/favicon.ico?v=1559555775811">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://hubingliang.github.io/styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://hubingliang.github.io">
  <img class="avatar" src="https://hubingliang.github.io/images/avatar.png?v=1559555775811" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              可能是最全的 Javascript 类型检查方案
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2019-01-02 ·
              </time>
              
                <a href="https://hubingliang.github.io/tag/JavaScript" class="post-tag">
                  # JavaScript
                </a>
              
                <a href="https://hubingliang.github.io/tag/Front-end" class="post-tag">
                  # Front-end
                </a>
              
            </div>
            
              <div class="post-feature-image" style="background-image: url('https://hubingliang.github.io/post-images/type.jpeg')">
              </div>
            
            <div class="post-content">
              <blockquote>
<p>本文首发于我的个人博客 ：<a href="http://brownhu.site/">brownhu.site</a></p>
</blockquote>
<h2 id="前言">前言</h2>
<p>类型检查在各种强类型语言（Typescript、Flow.js）出现之前一直是我们手动检查的，检查的方式也是多种多样。本文尽量总结出所有类型最优的检查方式，和解释所有方式的原理，如果有错误请各位大佬指正，除此之外对于类型检查当然拥抱强类型我觉得才是未来。</p>
<p>es6 之后新加入了 Symbol 类型，目前为止 JavaScript 一共有 7 种类型，但其中还有分类（set WeakSet Map WeakMap），我们就基于这些类型来探索：</p>
<ul>
<li>null</li>
<li>undefined</li>
<li>boolean</li>
<li>number</li>
<li>string</li>
<li>object (set WeakSet Map WeakMap)</li>
<li>symbol(ES6 中新增)</li>
</ul>
<h2 id="typeof">Typeof</h2>
<p>首先是 Typeof，Typeof 可能是最多人所熟知的判断类型的方法，但是它并不完美，在有些情况下它的判断是有偏差的，我们来看看几个例子：</p>
<pre><code class="language-js">// 首先判断基本类型
typeof 1 // number
typeof 'Hellow world !' // string
typeof true // boolean
typeof null // object
typeof undefined // undefined

let s = Symbol()
typeof s // symbol
</code></pre>
<p>可以看到 null 的判断出了错误，这个大家看面试题也或多或少知道这个坑。
然后我们再来看看引用类型：</p>
<pre><code class="language-js">const obj = Object.create(null) // 之所以这样创建是因为编程习惯...
function foo() {}
const arr = []
const s = new Set()
const ws = new WeakSet()
const m = new Map()
const wm = new WeakMap()

typeof obj // object
typeof foo // function
typeof arr // object
typeof s // object
typeof ws // object
typeof m // object
typeof wm // object
</code></pre>
<p>我们发现 typeof 在判断引用类型的时候并不能区分除了 function 以外其他类型的区别。至于为什么会出现这样的情况，就要看看 typeof 的原理。</p>
<h3 id="typeof-原理">typeof 原理</h3>
<p>在说原理之前需要先知道，js 是怎么储存数据类型的？</p>
<p>JavaScript 在底层储存变量时出于性能考虑会把数据的类型用前三位表示，typeof 就是通过前三位来判断类型：</p>
<ul>
<li>000: 对象</li>
<li>001: 整数</li>
<li>010: 浮点数</li>
<li>100: 字符串</li>
<li>110: 布尔</li>
</ul>
<p>两个特殊类型：</p>
<ul>
<li>undefined: -2^30</li>
<li>null: 全是 0</li>
</ul>
<p>因为 null 的机器码是全 0，它的类型标签自然就是 000，所以 typeof null 返回&quot;object&quot;。</p>
<h2 id="instanceof">instanceof</h2>
<p>instanceof 是有局限性的，它要求判断的目标必须是一个对象，与此同时 instanceof 的原理是判断只要右边的 prototype 出现在左边的原型链上就返回 true。所以说 instanceof 是判断一个实例是否是其父类型或者祖先类型的实例更为恰当。</p>
<p>代码的基本实现：</p>
<pre><code class="language-js">function instance_of(L, R) {    // L 表示左表达式，R 表示右表达式
 var O = R.prototype;           // 取 R 的显示原型
 L = L.__proto__;               // 取 L 的隐式原型
 while (true) { 
   if (L === null) 
     return false; 
   if (O === L)                 // 当 O 严格等于 L 时，返回 true 
     return true; 
   L = L.__proto__; 
 } 
}
</code></pre>
<p>还是看例子比较直接：</p>
<pre><code class="language-js">const obj1 = Object.create(null)
const obj2 = {}

obj1 instanceof Object // false
obj2 instanceof Object // true
</code></pre>
<p>通过这个例子你能很明确的想明白 instanceof 的原理，因为 obj1 是通过<code>Object.create(null)</code>来创建的，它原型链上什么都没有：</p>
<p><img src="https://i.loli.net/2019/01/02/5c2c8b9a13878.png" alt=""></p>
<p>而直接通过<code>{}</code>赋值生成的对象它的<code>_proto_</code>是指向 Object 的：</p>
<p><img src="https://i.loli.net/2019/01/02/5c2c8bc36b1f2.png" alt=""></p>
<p>所以判断结果就会有不同，</p>
<h2 id="objectprototypetostringcall">Object.prototype.toString.call()</h2>
<p>这个方法可以说是目前比较全面的类型判断方法了，还是看看例子：</p>
<pre><code class="language-js">Object.prototype.toString.call(null) // &quot;[object Null]&quot;
Object.prototype.toString.call(undefined) // &quot;[object Undefined]&quot;
Object.prototype.toString.call(123) // &quot;[object Number]&quot;
Object.prototype.toString.call(true) // &quot;[object Boolean]&quot;
Object.prototype.toString.call('Hellow world !') // &quot;[object String]&quot;
Object.prototype.toString.call({ a: 123 }) // &quot;[object Object]&quot;
Object.prototype.toString.call(Symbol()) // &quot;[object Symbol]&quot;
Object.prototype.toString.call([1, 2, 3]) // &quot;[object Array]&quot;
Object.prototype.toString.call(function a() {}) // &quot;[object Function]&quot;
Object.prototype.toString.call(new Date()) // &quot;[object Date]&quot;
Object.prototype.toString.call(Math) // &quot;[object Math]&quot;
Object.prototype.toString.call(new Set()) // &quot;[object Set]&quot;
Object.prototype.toString.call(new WeakSet()) // &quot;[object WeakSet]&quot;
Object.prototype.toString.call(new Map()) // &quot;[object Map]&quot;
Object.prototype.toString.call(new WeakMap()) // &quot;[object WeakMap]&quot;,/'.lk
</code></pre>
<p>可以说<code>Object.prototype.toString.call()</code>在大部分类型的考验下都不落下风，可以说是比较完美的类型检查了。
至于原理大家可以移步至<a href="https://segmentfault.com/a/1190000009407558">谈谈 Object.prototype.toString</a></p>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://hubingliang.github.io/post/hello-gridea">
              <h3 class="post-title">
                Hello Gridea
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://hubingliang.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
